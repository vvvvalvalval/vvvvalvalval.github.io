<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://blogawesome.com/' rel='self' type='application/rss+xml'/>
<title>
Val on Programming
</title>
<link>
http://blogawesome.com/
</link>
<description>
This blog is awesome
</description>
<lastBuildDate>
Wed, 16 Sep 2015 23:38:44 +0200
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://blogawesome.com/posts/2015-09-16-bottup-approach-to-reagent-state.html
</guid>
<link>
http://blogawesome.com/posts/2015-09-16-bottup-approach-to-reagent-state.html
</link>
<title>
A bottom-up approach to state in Reagent
</title>
<description>
&lt;p&gt;In this post, I'll present an alternative way of managing state in Reagent applications to what is currently made popular by libraries like &lt;a href='https://github.com/Day8/re-frame'&gt;Re-frame&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;tl;dr&quot;&gt;&lt;/a&gt;TL;DR&lt;/h2&gt;&lt;p&gt;We'll be able to declare 'local state' inside our Reagent components, which feels like ephemeral local atoms but is accessible globally and is Figwheel-reloadable.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;End result&lt;/strong&gt; : &lt;iframe src=&quot;https://player.vimeo.com/video/139510973&quot; width=&quot;100%&quot; height=&quot;330&quot; frameborder=&quot;0&quot; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;&lt;p&gt;(watch it in HD &lt;a href=&quot;https://vimeo.com/139510973&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;)&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;rationale&quot;&gt;&lt;/a&gt;Rationale&lt;/h2&gt;&lt;p&gt;From what I have seen, the currently most popular approach to state management in Reagent applications is to have one global Reactive Atom and to centralize the behaviour for updating this Ratom.&lt;/p&gt;&lt;p&gt;I completely agree that this approach is very sound for a large space of applications; it also has the advantage of making your code &lt;a href='https://github.com/bhauman/lein-figwheel#writing-reloadable-code'&gt;Figwheel-reloadable&lt;/a&gt; out of the box.&lt;/p&gt;&lt;p&gt;However, I do believe this approach has its limitations. Basing everything on a global ratom encourages your components to leverage a lot of context, making them less 'portable'. More importantly, I find this forces you to have a top-down approach to state management: you need to design the whole schema for your app state, and account for everything that could happen to it from the very start.&lt;/p&gt;&lt;p&gt;Sometimes, I feel I do not want this. Instead, I want my components to behave not as partial views of some global state, but as 'micro-applications', managing their own state instead of deferring this to some global decision maker. I like the idea that my components are autonomous, and can just be plugged into their parents without much knowledge of their context. This is what I call a &lt;em&gt;bottom-up&lt;/em&gt; approach to state management. &lt;span class=&quot;sn&quot;&gt;This is about the only way of doing things in libraries like AngularJS, in which directives just have local state and are meant to be autonomous. What I find great in Reagent is that I can combine both approaches.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;In this post, I'll present a way of achieving this, while retaining some of the great benefits of the top-down approach.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;requirements&quot;&gt;&lt;/a&gt;Requirements&lt;/h2&gt;&lt;p&gt;Our goal is to abide by the following requirements :&lt;/p&gt;&lt;ol&gt;&lt;li&gt;We want to make Reagent components with local state. In particular, the lifecycle of this local state is bound to the lifecycle of the component: it gets initialized when the component mounts, it gets cleaned up when the component unmounts.&lt;/li&gt;&lt;li&gt;We want this local state managed by the component, not externally&lt;/li&gt;&lt;li&gt;This 'local state' is actually perceptible from the global Reactive Atom of our app. This way, our system has the 'all state in one place' property, a.k.a 'email me your state and I'll see exactly what you see'.&lt;/li&gt;&lt;li&gt;This local state is &lt;em&gt;reloadable&lt;/em&gt;, i.e when we are developing with Figwheel, we don't have to re-create this state each time we make a code change.&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;a name=&quot;the&amp;#95;traditional&amp;#95;approach&amp;#95;to&amp;#95;local-state&amp;#95;in&amp;#95;reagent&quot;&gt;&lt;/a&gt;The traditional approach to local-state in Reagent&lt;/h2&gt;&lt;p&gt;As we can learn from the &lt;a href='https://reagent-project.github.io/'&gt;project page&lt;/a&gt;, the traditional way of making components with local state is as follows:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;instead of writing a rendering function, you write a 'wrapper' function which &lt;em&gt;returns&lt;/em&gt; a rendering function.&lt;/li&gt;&lt;li&gt;the 'wrapper' function initializes some local state in the form of ratoms stored in locals of the wrapper function&lt;/li&gt;&lt;li&gt;the rendering function just closes over these locals and uses them.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This is all very neat and intuitive, but it does not quite comply to our requirements : it's not reachable from our global state ratom, and it's not figwheel-reloadable.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;strategy&quot;&gt;&lt;/a&gt;Strategy&lt;/h2&gt;&lt;p&gt;Here is how we'll implement this :&lt;/p&gt;&lt;ul&gt;&lt;li&gt;we still have a unique global ratom, which will hold &lt;em&gt;all the state&lt;/em&gt; of the application (including component-local state)&lt;/li&gt;&lt;li&gt;instead of creating local ratoms, stateful components will be handed a 'location' (a Cursor) in the global state where to put their local state.&lt;/li&gt;&lt;li&gt;they will initialize this local state when they mount, and clean it when they unmount&lt;/li&gt;&lt;li&gt;we'll also need some tricks to make this robust to figwheel code reloads.&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;example&quot;&gt;&lt;/a&gt;Example&lt;/h2&gt;&lt;p&gt;I'll demonstrate this with a very poor, ugly version of TODO MVC.&lt;/p&gt;&lt;p&gt;Let's first lay out the 'model' of our app:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;require '&amp;#91;reagent.core :as r&amp;#93;&amp;#41;

;; this atom holds the global state, we use `defonce` to make it reloadable
&amp;#40;defonce todo-state-atom &amp;#40;r/atom {:todos &amp;#91;&amp;#93;}&amp;#41;&amp;#41;

;; here's a little helper to generate unique ids
&amp;#40;defonce next-id &amp;#40;atom 0&amp;#41;&amp;#41;
&amp;#40;defn gen-id &amp;#91;&amp;#93; &amp;#40;swap! next-id inc&amp;#41;&amp;#41;

;; these 3 functions are for manipulating the state
&amp;#40;defn add-todo &amp;#91;todo-state&amp;#93; &amp;#40;update todo-state :todos conj {:id &amp;#40;gen-id&amp;#41; :text &amp;quot;&amp;quot;}&amp;#41;&amp;#41;

&amp;#40;defn delete-todo &amp;#91;todo-state {:keys &amp;#91;id&amp;#93;}&amp;#93;
  &amp;#40;update todo-state :todos &amp;#40;fn &amp;#91;todos&amp;#93; &amp;#40;-&amp;gt;&amp;gt; todos &amp;#40;remove #&amp;#40;= &amp;#40;:id %&amp;#41; id&amp;#41;&amp;#41; vec&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn update-todo &amp;#91;todo-state {:keys &amp;#91;id&amp;#93; :as todo}&amp;#93;
  &amp;#40;update todo-state :todos &amp;#40;fn &amp;#91;todos&amp;#93; &amp;#40;-&amp;gt;&amp;gt; todos &amp;#40;map #&amp;#40;if &amp;#40;= &amp;#40;:id %&amp;#41; id&amp;#41; todo %&amp;#41;&amp;#41; vec&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, let's see how to implement the view.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;the&amp;#95;traditional&amp;#95;way:&amp;#95;with&amp;#95;old&amp;#95;fashioned&amp;#95;locals&quot;&gt;&lt;/a&gt;The traditional way: with old fashioned locals&lt;/h3&gt;&lt;p&gt;As a reference for comparison, we'll start by implementing it the 'traditional' Reagent way : with local ratoms to hold the local state.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; ... and here's our UI :
&amp;#40;declare &amp;lt;todos-list&amp;gt; &amp;lt;todo-item&amp;gt;&amp;#41;

&amp;#40;defn &amp;lt;todos-list&amp;gt; &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;update-me! #&amp;#40;swap! todo-state-atom update-todo %&amp;#41;
        delete-me! #&amp;#40;swap! todo-state-atom delete-todo %&amp;#41;&amp;#93;
    &amp;#91;:div.container
     &amp;#91;:h2 &amp;quot;TODO&amp;quot;&amp;#93;
     &amp;#91;:ul
      &amp;#40;for &amp;#91;todo &amp;#40;:todos @todo-state-atom&amp;#41;&amp;#93;
        &amp;#94;{:key &amp;#40;:id todo&amp;#41;} &amp;#91;&amp;lt;todo-item&amp;gt; todo update-me! delete-me!&amp;#93;
        &amp;#41;&amp;#93;
     &amp;#91;:button.btn.btn-success {:on-click #&amp;#40;swap! todo-state-atom add-todo&amp;#41;} &amp;quot;Add&amp;quot;&amp;#93;

     &amp;#91;:div
      &amp;#91;:h2 &amp;quot;State&amp;quot;&amp;#93;
      &amp;#91;:pre &amp;#40;with-out-str &amp;#40;pprint/pprint @todo-state-atom&amp;#41;&amp;#41;&amp;#93;&amp;#93;&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn &amp;lt;todo-item&amp;gt; &amp;#91;{:keys &amp;#91;id&amp;#93;} update-me! delete-me!&amp;#93;
  &amp;#40;let &amp;#91;local-state &amp;#40;r/atom {:editing false}&amp;#41;&amp;#93;
    &amp;#40;fn &amp;#91;{:keys &amp;#91;id text&amp;#93; :as todo} update-me! delete-me!&amp;#93;
      &amp;#40;if &amp;#40;:editing @local-state&amp;#41;
        &amp;#91;:li
         &amp;#91;:span &amp;quot;type in some awesome text :&amp;quot;&amp;#93;
         &amp;#91;:input {:type &amp;quot;text&amp;quot; :value text :on-change #&amp;#40;update-me! &amp;#40;assoc todo :text &amp;#40;-&amp;gt; % .-target .-value&amp;#41;&amp;#41;&amp;#41;}&amp;#93;
         &amp;#91;:button {:on-click #&amp;#40;swap! local-state assoc :editing false&amp;#41;} &amp;quot;Done&amp;quot;&amp;#93;&amp;#93;
        &amp;#91;:li
         &amp;#91;:span &amp;quot;text: &amp;quot; text&amp;#93;
         &amp;#91;:button {:on-click #&amp;#40;swap! local-state assoc :editing true&amp;#41;} &amp;quot;Edit&amp;quot;&amp;#93;
         &amp;#91;:button {:on-click #&amp;#40;delete-me! todo&amp;#41;} &amp;quot;Remove&amp;quot;&amp;#93;&amp;#93;&amp;#41;
      &amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is the most straightforward way of doing things, but as we said earlier, it does not yield an optimal result: the local state is not reachable from the global atom, not does it survive code reloads. Let's make this better.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;the&amp;#95;new&amp;#95;way:&amp;#95;with&amp;#95;managed&amp;#95;cursors&quot;&gt;&lt;/a&gt;The new way: with managed cursors&lt;/h3&gt;&lt;p&gt;We'll store the local state in cursors of the global ratom, instead of ratoms stored in locals.&lt;/p&gt;&lt;p&gt;Of course, now that we're not using locals, we can no longer rely on garbage collection to clean up after us, so we have to do it explicitly using lifecycle methods.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; in this cursor, we'll put the local state of each list item
&amp;#40;defonce todos-state-cursor &amp;#40;r/cursor todo-state-atom &amp;#91;:todo-state&amp;#93;&amp;#41;&amp;#41;

&amp;#40;declare &amp;lt;todos-list&amp;gt; &amp;lt;todo-item&amp;gt; &amp;lt;todo-item-plugged&amp;gt;&amp;#41;

&amp;#40;defn &amp;lt;todos-list&amp;gt; &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;update-me! #&amp;#40;swap! todo-state-atom update-todo %&amp;#41;
        delete-me! #&amp;#40;swap! todo-state-atom delete-todo %&amp;#41;&amp;#93;
    &amp;#91;:div.container
     &amp;#91;:h2 &amp;quot;TODO&amp;quot;&amp;#93;
     &amp;#91;:ul
      &amp;#40;for &amp;#91;todo &amp;#40;:todos @todo-state-atom&amp;#41;&amp;#93;
        &amp;#94;{:key &amp;#40;:id todo&amp;#41;} &amp;#91;&amp;lt;todo-item&amp;gt; todos-state-cursor todo update-me! delete-me!&amp;#93;
        &amp;#41;&amp;#93;
     &amp;#91;:button.btn.btn-success {:on-click #&amp;#40;swap! todo-state-atom add-todo&amp;#41;} &amp;quot;Add&amp;quot;&amp;#93;

     &amp;#91;:div
      &amp;#91;:h2 &amp;quot;State&amp;quot;&amp;#93;
      &amp;#91;:pre &amp;#40;with-out-str &amp;#40;pprint/pprint @todo-state-atom&amp;#41;&amp;#41;&amp;#93;&amp;#93;&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn &amp;lt;todo-item&amp;gt; &amp;#91;parent-atom {:keys &amp;#91;id&amp;#93;} update-me! delete-me!&amp;#93;
  &amp;#40;let &amp;#91;local-state-cursor &amp;#40;r/cursor parent-atom &amp;#91;id&amp;#93;&amp;#41;&amp;#93;
    &amp;#40;r/create-class
      {:component-will-mount &amp;#40;fn &amp;#91;&amp;#95;&amp;#93; &amp;#40;when-not @local-state-cursor ;; setting up
                                       &amp;#40;reset! local-state-cursor {:editing false}&amp;#41;&amp;#41;&amp;#41;
       :component-will-unmount &amp;#40;fn &amp;#91;&amp;#95;&amp;#93; &amp;#40;swap! parent-atom dissoc id&amp;#41;&amp;#41; ;; cleaning up
       :reagent-render
       &amp;#40;fn &amp;#91;parent-atom {:keys &amp;#91;id text&amp;#93; :as todo} update-me! delete-me!&amp;#93;
         &amp;#40;if &amp;#40;:editing @local-state-cursor&amp;#41;
           &amp;#91;:li
            &amp;#91;:span &amp;quot;type in some awesome text :&amp;quot;&amp;#93;
            &amp;#91;:input {:type &amp;quot;text&amp;quot; :value text :on-change #&amp;#40;update-me! &amp;#40;assoc todo :text &amp;#40;-&amp;gt; % .-target .-value&amp;#41;&amp;#41;&amp;#41;}&amp;#93;
            &amp;#91;:button {:on-click #&amp;#40;swap! local-state-cursor assoc :editing false&amp;#41;} &amp;quot;Done&amp;quot;&amp;#93;&amp;#93;
           &amp;#91;:li
            &amp;#91;:span &amp;quot;text: &amp;quot; text&amp;#93;
            &amp;#91;:button {:on-click #&amp;#40;swap! local-state-cursor assoc :editing true&amp;#41;} &amp;quot;Edit&amp;quot;&amp;#93;
            &amp;#91;:button {:on-click #&amp;#40;delete-me! todo&amp;#41;} &amp;quot;Remove&amp;quot;&amp;#93;&amp;#93;&amp;#41;
         &amp;#41;}&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We have now full visibility of the whole state of our app, and can manipulate all of it using the REPL. This is a big improvement.&lt;/p&gt;&lt;p&gt;However, we haven't achieved reloadability yet. Let's see how it goes.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;making&amp;#95;it&amp;#95;reloadable&quot;&gt;&lt;/a&gt;Making it reloadable&lt;/h3&gt;&lt;p&gt;This is kind of tricky.&lt;/p&gt;&lt;p&gt;In order to reload the code, our app has to be re-mounted into the DOM on each code reload. I'm using the &lt;a href='https://github.com/bhauman/figwheel-template'&gt;figwheel Leiningen template&lt;/a&gt;, which does it by calling a &lt;code&gt;mount-root&lt;/code&gt; function on each reload :&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn mount-root &amp;#91;&amp;#93;
  &amp;#40;r/render &amp;#91;&amp;lt;todos-list&amp;gt;&amp;#93; &amp;#40;.getElementById js/document &amp;quot;app&amp;quot;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The problem is, each time a new version gets mounted, the old version gets unmounted. As a consequence, the &lt;code&gt;:component-will-unmount&lt;/code&gt; function we defined above is called, and diligently erases our local state.&lt;/p&gt;&lt;p&gt;We need to find a way of informing our component that the unmounting is caused by a Figwheel reload, so that it does not erase its state. This is made harder by the fact that mounting happens asynchronously.&lt;/p&gt;&lt;p&gt;The best way I've found is to set up a flag when the reloading happens, and leave it up long enough that the DOM can mount :&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defonce reloading-state &amp;#40;atom false&amp;#41;&amp;#41; ;; note that we're using a regular atom: the whole point is not to interfere with Reagent here.

&amp;#40;defn reload! &amp;#91;timeout&amp;#93;
  &amp;#40;when timeout
    &amp;#40;reset! reloading-state true&amp;#41;
    &amp;#40;js/setTimeout #&amp;#40;reset! reloading-state false&amp;#41; timeout&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn reloading? &amp;#91;&amp;#93; @reloading-state&amp;#41;

;; ...

&amp;#40;defn mount-root &amp;#91;&amp;#93;
  &amp;#40;reload! 200&amp;#41;
  &amp;#40;r/render &amp;#91;&amp;lt;todos-list&amp;gt;&amp;#93; &amp;#40;.getElementById js/document &amp;quot;app&amp;quot;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can use this by making a tiny change to our component definition :&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn &amp;lt;todo-item&amp;gt; &amp;#91;parent-atom {:keys &amp;#91;id&amp;#93;} update-me! delete-me!&amp;#93;
       ;; ...
       :component-will-unmount &amp;#40;fn &amp;#91;&amp;#95;&amp;#93; &amp;#40;when-not &amp;#40;reloading?&amp;#41;
                                         &amp;#40;swap! parent-atom dissoc id&amp;#41;&amp;#41;&amp;#41;
        ;; ...
       &amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To be honest, I'm not very proud of it, but it works; and given that it only affects our development environment, I don't feel too worried using this little hack.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;making&amp;#95;it&amp;#95;less&amp;#95;tedious:&amp;#95;pluggable&amp;#95;components&quot;&gt;&lt;/a&gt;Making it less tedious: pluggable components&lt;/h3&gt;&lt;p&gt;This is great, but it's a pity that we have to resort to lifecycle methods and explicit calls to our &lt;code&gt;&amp;#40;reloading?&amp;#41;&lt;/code&gt; hack every time we want a component with local state, especially since we're using Reagent, which usually excels as hiding away this sort of things.&lt;/p&gt;&lt;p&gt;Fortunately, we can make it more practical. A few weeks ago, I experimented with the concept of so-called (by me) &lt;a href='https://github.com/vvvvalvalval/reagent-pluggable-components-poc'&gt;&amp;#42;pluggable components&amp;#42;&lt;/a&gt;,  which are a way of writing stateful components which have a cleanup phase without writing the same 'lifecyle methods recipes' over and over again.&lt;/p&gt;&lt;p&gt;I won't detail how it works here (although there's &lt;a href='https://github.com/vvvvalvalval/reagent-pluggable-components-poc/blob/master/src/cljs/reagent&amp;#95;plug/core.cljs#L13'&gt;not much&lt;/a&gt; to it), but basically here's the amount of work it takes :&lt;/p&gt;&lt;p&gt;We first define a 'managed cursor' recipe, which encapsulates the 'local cursor lifecycle' logic we coded above :&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defmethod make-plug ::r/managed-cursor &amp;#91;&amp;#91;&amp;#95;&amp;#93; &amp;#91;parent-ratom key&amp;#93;&amp;#93;
  &amp;#40;let &amp;#91;curs &amp;#40;r/cursor parent-ratom &amp;#91;key&amp;#93;&amp;#41;&amp;#93;
    &amp;#40;-&amp;gt;Plug curs #&amp;#40;do nil&amp;#41; #&amp;#40;when-not &amp;#40;reloading?&amp;#41; &amp;#40;swap! parent-ratom dissoc key&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;From now on, we'll be able to reuse this recipe for any stateful component. Let's see how that goes for &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; :&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn &amp;lt;todos-list&amp;gt; &amp;#91;&amp;#93;
      ;; ...
      &amp;#40;for &amp;#91;todo &amp;#40;:todos @todo-state-atom&amp;#41;&amp;#93;
        ;; the external API for the component is a tiny bit different
        &amp;#94;{:key &amp;#40;:id todo&amp;#41;} &amp;#91;&amp;lt;todo-item&amp;gt; &amp;#91;todos-state-cursor &amp;#40;:id todo&amp;#41;&amp;#93; todo update-me! delete-me!&amp;#93;
        &amp;#41;&amp;#93;
      ;; ...
     &amp;#41;


&amp;#40;defplugged &amp;lt;todo-item&amp;gt;
  &amp;#91;&amp;#40;local-state-cursor &amp;#91;::r/managed-cursor&amp;#93;&amp;#41; ;; `local-state-cursor` gets injected into our component, and will be cleaned up once unmounted
   {:keys &amp;#91;id&amp;#93;} update-me! delete-me!&amp;#93;
  &amp;#40;when-not @local-state-cursor
    &amp;#40;reset! local-state-cursor {:editing false}&amp;#41;&amp;#41;
  &amp;#40;fn &amp;#91;&amp;#95; {:keys &amp;#91;id text&amp;#93; :as todo} update-me! delete-me!&amp;#93;
    &amp;#40;if &amp;#40;:editing @local-state-cursor&amp;#41;
      &amp;#91;:li
       &amp;#91;:span &amp;quot;type in some text : &amp;quot;&amp;#93;
       &amp;#91;:input.form-control {:type &amp;quot;text&amp;quot; :value text :style {:width &amp;quot;100px&amp;quot; :display &amp;quot;inline-block&amp;quot;}
                             :on-change #&amp;#40;update-me! &amp;#40;assoc todo :text &amp;#40;-&amp;gt; % .-target .-value&amp;#41;&amp;#41;&amp;#41;}&amp;#93;
       &amp;quot; &amp;quot;
       &amp;#91;:button.btn.btn-success {:on-click #&amp;#40;swap! local-state-cursor assoc :editing false&amp;#41;} &amp;quot;Done&amp;quot;&amp;#93;&amp;#93;
      &amp;#91;:li
       &amp;#91;:span &amp;quot;text: &amp;quot; text &amp;quot; &amp;quot;&amp;#93;
       &amp;#91;:button.btn.btn-primary {:on-click #&amp;#40;swap! local-state-cursor assoc :editing true&amp;#41;} &amp;quot;Edit&amp;quot;&amp;#93; &amp;quot; &amp;quot;
       &amp;#91;:button.btn.btn-danger {:on-click #&amp;#40;delete-me! todo&amp;#41;} &amp;quot;Remove&amp;quot;&amp;#93;&amp;#93;&amp;#41;
    &amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It's now as lightweight as we'd expect of Reagent!&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;wrapping&amp;#95;up&quot;&gt;&lt;/a&gt;Wrapping up&lt;/h2&gt;&lt;p&gt;I'm very excited about the possibilities of this. We can now have state that feels local, while being reachable and reloadable, with the huge benefits that come with it. Of course, this concept still has to be proven, and this implementation may be suboptimal.&lt;/p&gt;&lt;p&gt;We're getting &lt;a href='https://www.youtube.com/watch?v=PUv66718DII'&gt;there&lt;/a&gt;!&lt;/p&gt;
</description>
<pubDate>
Wed, 16 Sep 2015 00:00:00 +0200
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts/2015-09-06-productive-git-setup.html
</guid>
<link>
http://blogawesome.com/posts/2015-09-06-productive-git-setup.html
</link>
<title>
Productive Git setup
</title>
<description>
&lt;p&gt;When getting started with Git, you don't always know there exist some trick to make you more productive with it. Here are a few, most of which are already in the &lt;a href='http://git-scm.com/book/en/v1/Git-Basics-Tips-and-Tricks'&gt;official documentation&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;installing&amp;#95;autocompletion&quot;&gt;&lt;/a&gt;Installing autocompletion&lt;/h2&gt; &lt;p&gt;When working with git from the command-line, it's very useful to have autocompletion for your branch/remote names, git commands, etc. Fortunately, there is a bash script for that.  &lt;/p&gt;&lt;p&gt;&lt;!--more--&gt;  &lt;/p&gt;&lt;p&gt;To achieve this, download &lt;a href='https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash'&gt;this file&lt;/a&gt;, put it under your home directory under the name .git-completion.bash, then reference it from your bash initialization file (either ~/.bash_profile or ~/.bashrc) :  &lt;/p&gt;&lt;pre&gt;&lt;code&gt;source &amp;#126;/.git-completion.bash
&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;&lt;a name=&quot;defining&amp;#95;aliases&quot;&gt;&lt;/a&gt;Defining aliases&lt;/h2&gt; &lt;h3&gt;&lt;a name=&quot;for&amp;#95;common&amp;#95;commands&quot;&gt;&lt;/a&gt;For common commands&lt;/h3&gt; &lt;p&gt;Commands like &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;branch&lt;/code&gt;, `checkout are so common that it's useful to type them with fewer characters.  To do so, you create git &lt;i&gt;aliases&lt;/i&gt; by typing the following commands in a terminal :  &lt;/p&gt;&lt;pre&gt;&lt;code&gt;git config --global alias.co checkout   
git config --global alias.br branch   
git config --global alias.ci commit   
git config --global alias.st status
&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Once you have done this, you can type co, br, ci, st every time you would normaly type checkout, branch, commit, status.  &lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;to&amp;#95;print&amp;#95;the&amp;#95;commits&amp;#95;graph&quot;&gt;&lt;/a&gt;To print the commits graph&lt;/h3&gt; &lt;p&gt;The following alias will enable you print a pretty representation of the commits graph in your terminal window :&lt;/p&gt;&lt;pre&gt;&lt;code&gt;git config --global alias.lg &amp;quot;log --graph --all --pretty=format:'%C&amp;#40;bold&amp;#41;%h%Creset -%C&amp;#40;auto&amp;#41;%d%Creset %s %C&amp;#40;green dim&amp;#41;&amp;#40;%cr&amp;#41;%Creset %C&amp;#40;ul&amp;#41;&amp;lt;%an&amp;gt;&amp;quot;  
&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Now, typing &lt;code&gt;git lg&lt;/code&gt; in your repository will print something like this :   &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/img/git-lg-screenshot.png&quot; width=&quot;100%&quot;&gt;  &lt;/p&gt;&lt;p&gt;The effect of setting aliases is to modify your ~/.gitconfig file, which should now look like this :&lt;/p&gt;&lt;pre&gt;&lt;code&gt;   &amp;#91;user&amp;#93;  
       name = Valentin Waeselynck  
       email = val@bandsquare.fr  
  &amp;#91;alias&amp;#93;  
       lg = log --graph --all --pretty=format:'%C&amp;#40;bold&amp;#41;%h%Creset -%C&amp;#40;auto&amp;#41;%d%Creset %s %C&amp;#40;green dim&amp;#41;&amp;#40;%cr&amp;#41;%Creset %C&amp;#40;ul&amp;#41;&amp;lt;%an&amp;gt;'  
       co = checkout  
       br = branch  
       ci = commit  
       st = status  
  &amp;#91;core&amp;#93;  
       editor = vim   
  &amp;#91;filter &amp;quot;media&amp;quot;&amp;#93;  
       clean = git media clean %f  
       smudge = git media smudge %f  
       required = true  
&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;&lt;a name=&quot;using&amp;#95;a&amp;#95;git&amp;#95;gui&amp;#95;client&quot;&gt;&lt;/a&gt;Using a git GUI client&lt;/h2&gt; &lt;p&gt;Working from the command line with the above config is enough for 95% of my everyday work.  But sometimes, I need a better visualisation tool (e.g for diffs) in my local environment, so I also use &lt;a href='https://www.sourcetreeapp.com/'&gt;SourceTree&lt;/a&gt;.&lt;/p&gt;
</description>
<pubDate>
Sun, 06 Sep 2015 00:00:00 +0200
</pubDate>
</item>
<item>
<guid>
http://blogawesome.com/posts/2015-09-06-Having-a-good-terminal-console-on-OS-X-in-2015.html
</guid>
<link>
http://blogawesome.com/posts/2015-09-06-Having-a-good-terminal-console-on-OS-X-in-2015.html
</link>
<title>
Having a good terminal console on OS X in 2015
</title>
<description>
 &lt;p&gt;As a programmer, your terminal console is part of your everyday life.  That's where you launch your local server, start your database, see your heroku logs, try out that mysterious command you found on some forum, etc.  Don't try to escape it; instead, learn to master it and make it comfortable enough that you feel at home using it.  &lt;/p&gt;&lt;p&gt;My current choice for a terminal on OSX is &lt;a href='http://iterm2.com/'&gt;ITerm2 (official website)&lt;/a&gt;.  &lt;/p&gt;&lt;p&gt;&lt;!--more--&gt;  &lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;installing&amp;#95;iterm2&quot;&gt;&lt;/a&gt;Installing ITerm2&lt;/h2&gt; &lt;p&gt;Nothing tricky here, just download it from the official website.  What you get is a zip archive that unpacks to a .app file. All you have to do is move that file to your Applications folder.  &lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;adding&amp;#95;some&amp;#95;colors&amp;#95;to&amp;#95;the&amp;#95;console&quot;&gt;&lt;/a&gt;Adding some colors to the console&lt;/h2&gt; &lt;p&gt;I like my console to have a dark background because it's easier on the eyes and environment-friendly.  Also I want to see some relevant information like current *nix user and current directory.  &lt;/p&gt;&lt;p&gt;For this I use a little shell script :&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;  # COLORFUL PROMPT  
  # uncomment for a colored prompt, if the terminal has the capability; turned  
  # off by default to not distract the user: the focus in a terminal window  
  # should be on the output of commands, not on the prompt  
  force&amp;#95;color&amp;#95;prompt=yes  
  if &amp;#91; -n &amp;quot;$force&amp;#95;color&amp;#95;prompt&amp;quot; &amp;#93;; then  
    if &amp;#91; -x /usr/bin/tput &amp;#93; &amp;amp;&amp;amp; tput setaf 1 &amp;gt;&amp;amp;/dev/null; then  
      # We have color support; assume it's compliant with Ecma-48  
      # &amp;#40;ISO/IEC-6429&amp;#41;. &amp;#40;Lack of such support is extremely rare, and such  
      # a case would tend to support setf rather than setaf.&amp;#41;  
      color&amp;#95;prompt=yes  
    else  
      color&amp;#95;prompt=  
    fi  
  fi  
  # ANSI color codes  
  RS=&amp;quot;\&amp;#91;\033&amp;#91;0m\&amp;#93;&amp;quot;  # reset  
  HC=&amp;quot;\&amp;#91;\033&amp;#91;1m\&amp;#93;&amp;quot;  # hicolor  
  UL=&amp;quot;\&amp;#91;\033&amp;#91;4m\&amp;#93;&amp;quot;  # underline  
  INV=&amp;quot;\&amp;#91;\033&amp;#91;7m\&amp;#93;&amp;quot;  # inverse background and foreground  
  FBLK=&amp;quot;\&amp;#91;\033&amp;#91;30m\&amp;#93;&amp;quot; # foreground black  
  FRED=&amp;quot;\&amp;#91;\033&amp;#91;31m\&amp;#93;&amp;quot; # foreground red  
  FGRN=&amp;quot;\&amp;#91;\033&amp;#91;32m\&amp;#93;&amp;quot; # foreground green  
  FYEL=&amp;quot;\&amp;#91;\033&amp;#91;33m\&amp;#93;&amp;quot; # foreground yellow  
  FBLE=&amp;quot;\&amp;#91;\033&amp;#91;34m\&amp;#93;&amp;quot; # foreground blue  
  FMAG=&amp;quot;\&amp;#91;\033&amp;#91;35m\&amp;#93;&amp;quot; # foreground magenta  
  FCYN=&amp;quot;\&amp;#91;\033&amp;#91;36m\&amp;#93;&amp;quot; # foreground cyan  
  FWHT=&amp;quot;\&amp;#91;\033&amp;#91;37m\&amp;#93;&amp;quot; # foreground white  
  BBLK=&amp;quot;\&amp;#91;\033&amp;#91;40m\&amp;#93;&amp;quot; # background black  
  BRED=&amp;quot;\&amp;#91;\033&amp;#91;41m\&amp;#93;&amp;quot; # background red  
  BGRN=&amp;quot;\&amp;#91;\033&amp;#91;42m\&amp;#93;&amp;quot; # background green  
  BYEL=&amp;quot;\&amp;#91;\033&amp;#91;43m\&amp;#93;&amp;quot; # background yellow  
  BBLE=&amp;quot;\&amp;#91;\033&amp;#91;44m\&amp;#93;&amp;quot; # background blue  
  BMAG=&amp;quot;\&amp;#91;\033&amp;#91;45m\&amp;#93;&amp;quot; # background magenta  
  BCYN=&amp;quot;\&amp;#91;\033&amp;#91;46m\&amp;#93;&amp;quot; # background cyan  
  BWHT=&amp;quot;\&amp;#91;\033&amp;#91;47m\&amp;#93;&amp;quot; # background white  
  #variables pointing to ANSI color codes  
  USER&amp;#95;CLR=&amp;quot;$RS$HC$FGRN&amp;quot; # the color of the user name, e.g 'val'  
  HOST&amp;#95;CLR=&amp;quot;$RS$FYEL&amp;quot; # the color of the host, e.g 'VVV-SATELLITE-P850'  
  LOC&amp;#95;CLR=&amp;quot;$RS$FGRN&amp;quot; # the color of the location, e.g '&amp;#126;/Documents'  
  MISC&amp;#95;CLR=&amp;quot;$RS$HC$FYEL&amp;quot; # the color of other symbols  
  if &amp;#91; &amp;quot;$color&amp;#95;prompt&amp;quot; = yes &amp;#93;; then  
    #PS1='${debian&amp;#95;chroot:+&amp;#40;$debian&amp;#95;chroot&amp;#41;}\&amp;#91;\033&amp;#91;01;32m\&amp;#93;\u@\h\&amp;#91;\033&amp;#91;00m\&amp;#93;:\&amp;#91;\033&amp;#91;01;34m\&amp;#93;\w\&amp;#91;\033&amp;#91;00m\&amp;#93;\$ '  
    # primary prompt : contains special characters an sequences for additional info about a session.  
    #PS1=&amp;quot;$HC$FYEL&amp;#91; $FBLE${debian&amp;#95;chroot:+&amp;#40;$debian&amp;#95;chroot&amp;#41;}\u$FYEL: $FBLE\w $FYEL&amp;#93;\\$ $RS&amp;quot;  
    PS1=&amp;quot;$HC$MISC&amp;#95;CLR&amp;#91; $USER&amp;#95;CLR\u$HOST&amp;#95;CLR@\h: $LOC&amp;#95;CLR\w $MISC&amp;#95;CLR&amp;#93;\n$USER&amp;#95;CLR\\$ $RS&amp;quot;  
    # secondary prompt shows just '&amp;gt;'  
    PS2=&amp;quot;$HC$FYEL&amp;gt; $RS&amp;quot;  
  else  
    #PS1='${debian&amp;#95;chroot:+&amp;#40;$debian&amp;#95;chroot&amp;#41;}\u@\h:\w\$ '  
    # primary prompt : contains special characters an sequences for additional info about a session.  
    PS1=&amp;quot;&amp;#91; \u: \w &amp;#93;\\$ &amp;quot;  
    # secondary prompt shows just '&amp;gt;'  
    PS2=&amp;quot;&amp;gt; &amp;quot;  
  fi  
  unset color&amp;#95;prompt force&amp;#95;color&amp;#95;prompt  
&lt;/code&gt;&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;To use it, I created a colorful&lt;i&gt;prompt.sh file with the above content which I put in a  ~/.my&lt;/i&gt;bash&lt;i&gt;config directory, then called it from my ~/.bash&lt;/i&gt;profile file (which is in charge of initializing my terminal) by adding these lines to it:  &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;&amp;#126;/.bash&amp;#95;profile&lt;/code&gt;&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;  # enable colorful prompt  
  source &amp;#126;/.my&amp;#95;bash&amp;#95;config/colorful&amp;#95;prompt.sh
 &lt;/code&gt;&lt;/pre&gt;  &lt;/p&gt;&lt;p&gt;You can do it all with a simple text editor like TextMate. Don't hesitate to change the colors to your liking, it should be easy from the above code.  Note that this also works on other *nix operating systems, not just OSX.  &lt;/p&gt;&lt;p&gt;Now you have a pretty terminal, which is the first step towards loving to work in the command line.  Next step is to make it more ergonomic.  &lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;using&amp;#95;iterm2&amp;#95;:&amp;#95;panes,&amp;#95;tabs,&amp;#95;profiles&amp;#95;and&amp;#95;window&amp;#95;arrangements&quot;&gt;&lt;/a&gt;Using ITerm2 : panes, tabs, profiles and window arrangements&lt;/h2&gt;  &lt;h3&gt;&lt;a name=&quot;organizing&quot;&gt;&lt;/a&gt;Organizing&lt;/h3&gt;  &lt;p&gt;The first thing I find practical in ITerm2 is the possibility to have several shell sessions open next to each other in the same window.  When using ITerm2, you can have several windows, each window has several tabs, each tab is split into panes.  &lt;/p&gt;&lt;p&gt;I recommend using only one window, making it full-screen, and having many tabs each split into a few panes.  It all looks like this :&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/img/iterm2-screenshot.png&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;small&gt;In this window, there are 6 tabs, and the current tab has 3 panes&lt;/small&gt;  &lt;/p&gt;&lt;p&gt;I'll typically have one or two tabs per project; for example, for a web development project,  I'll have a tab for the frontend and one for the backend. On the backend tab,  I'll have a small pane for my local database server, one for my backend server,  and a large one for git commands and and other command-line stuff.  &lt;/p&gt;&lt;p&gt;To achieve such a layout, use the Shell menu of ITerm2, where you can see options to create new tabs (CMD-T) and split them into panes (CMD-D, CMD-MAJ-D). You can navigate across tabs with CMD-LEFT and CMD-RIGHT.  &lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;having&amp;#95;a&amp;#95;ready-to-use&amp;#95;terminal&amp;#95;with&amp;#95;profiles&amp;#95;and&amp;#95;window&amp;#95;arrangements&quot;&gt;&lt;/a&gt;Having a ready-to-use terminal with profiles and window arrangements&lt;/h3&gt; &lt;p&gt;You don't want to have to re-create this arrangement every time you start ITerm2.  This is why there are profiles and window arrangements.   &lt;/p&gt;&lt;p&gt;A profile is essentially a pre-defined file system location for a shell session to start in.&lt;br /&gt; If you want to always be in the same location in a certain pane, you'll have to create a profile for it.  &lt;/p&gt;&lt;p&gt;To create a profile, do Profiles &gt; Open Profiles &gt; Edit Profile, then +, then you enter the name and file system location for this profile and you're good to go.  &lt;/p&gt;&lt;p&gt;To have a pane with a specific profile, it's a bit tricky.  Place yourself in a pane, click Shell &gt; Split Vertically, then you will prompted for a profile for the newly created pane.  After that, you can close the older pane. I haven't found a more direct way.  &lt;/p&gt;&lt;p&gt;The last thing to do to save your beautiful tabs/panes layout is to save it in a window arrangement.  To do so, go to Window &gt; Save Window Arrangement.  If you want to start ITerm2 with always the same window arrangement (which you probably do),  you can set a default window arrangement in the Preferences.  &lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;wrapping&amp;#95;up&quot;&gt;&lt;/a&gt;Wrapping up&lt;/h2&gt; &lt;p&gt;I hope this will make your relationship to terminal consoles happier.  As Obi-Wan Kenobi said to Luke in the Millennium Falcon, this is your first step into a larger world.  I was actually pleasantly surprised to discover ITerm2 for Mac, I haven't found something as ergonomic for Ubuntu.&lt;/p&gt;
</description>
<pubDate>
Sun, 06 Sep 2015 00:00:00 +0200
</pubDate>
</item>
</channel>
</rss>
