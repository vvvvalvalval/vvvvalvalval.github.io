<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='http://vvvvalvalval.github.io/' rel='self' type='application/rss+xml'/>
<title>
Val on Programming
</title>
<link>
http://vvvvalvalval.github.io/
</link>
<description>

</description>
<lastBuildDate>
Mon, 10 Jul 2017 22:37:27 +0200
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
http://vvvvalvalval.github.io/posts/2017-07-08-Datomic-this-is-not-the-history-youre-looking-for.html
</guid>
<link>
http://vvvvalvalval.github.io/posts/2017-07-08-Datomic-this-is-not-the-history-youre-looking-for.html
</link>
<title>
Datomic: this is not the history you're looking for
</title>
<description>
&lt;p&gt;In this post, I'll describe some common pitfalls regarding the use of the 'time-travel' features of Datomic  (&lt;a href='http://docs.datomic.com/javadoc/datomic/Database.html#asOf-java.lang.Object-'&gt;&lt;code&gt;db.asOf&amp;#40;&amp;#41;&lt;/code&gt;&lt;/a&gt;,  &lt;a href='http://docs.datomic.com/javadoc/datomic/Database.html#history--'&gt;&lt;code&gt;db.history&amp;#40;&amp;#41;&lt;/code&gt;&lt;/a&gt;,  &lt;a href='http://docs.datomic.com/transactions.html'&gt;&lt;code&gt;:db/txInstant&lt;/code&gt;&lt;/a&gt;).&lt;/p&gt;&lt;p&gt;We'll see that, unlike what many people think when they start using Datomic, these historical features of Datomic are not so useful for implementing custom time-travel features in the business logic of applications - rather for generic database-related tasks.&lt;/p&gt;&lt;p&gt;I'll then try to describe the distinction between 'event time' and 'recording time', which is my analysis of what Datomic historical features essentially represent.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;a&amp;#95;datomic&amp;#95;refresher&quot;&gt;&lt;/a&gt;A Datomic refresher&lt;/h2&gt;&lt;p&gt;These are what I call the 'time-travel features' of Datomic in this post:&lt;ul&gt;&lt;li&gt;&lt;a href='http://docs.datomic.com/javadoc/datomic/Database.html#asOf-java.lang.Object-'&gt;&lt;code&gt;db.asOf&amp;#40;&amp;#41;&lt;/code&gt;&lt;/a&gt; lets you obtain a past version of the database at any point in time&lt;/li&gt;&lt;li&gt;&lt;a href='http://docs.datomic.com/javadoc/datomic/Database.html#history--'&gt;&lt;code&gt;db.history&amp;#40;&amp;#41;&lt;/code&gt;&lt;/a&gt; gives you a view off all the datoms (i.e facts) ever added to your database, even if they've been retracted since then&lt;/li&gt;&lt;li&gt;&lt;a href='http://docs.datomic.com/transactions.html'&gt;&lt;code&gt;:db/txInstant&lt;/code&gt;&lt;/a&gt; annotates every transaction (i.e 'write') with the time at which it was processed.&lt;/li&gt;&lt;/ul&gt;Essentially, these features give you access to the past versions of the database - not just the present one. This makes it very tempting to use them for applications that need to provide time-related features of their own.  As we'll see, this approach comes with significant caveats.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;the&amp;#95;problem&amp;#95;by&amp;#95;examples&quot;&gt;&lt;/a&gt;The problem by examples&lt;/h2&gt;&lt;h3&gt;&lt;a name=&quot;problem&amp;#95;1:&amp;#95;accessing&amp;#95;revisions&amp;#95;of&amp;#95;documents&quot;&gt;&lt;/a&gt;Problem 1: accessing revisions of documents&lt;/h3&gt;&lt;p&gt;Imagine for instance you're implementing some blogging platform on top of Datomic,  and you want to give users the ability to view every past version of a blog post.  Instinctively, since you're using Datomic, you'd want to reach out to &lt;code&gt;db.asOf&amp;#40;&amp;#41;&lt;/code&gt; for this task:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn get-blog-post-as-of
  &amp;quot;Given a database value `db`, blog post id `post-id`, and time `t`,
  returns the version of the blog post as of `t`&amp;quot;
  &amp;#91;db post-id t&amp;#93;
  &amp;#40;d/pull &amp;#40;d/as-of db t&amp;#41;
    '&amp;#91;:blog.post/title
      :blog.post/content&amp;#93;
    &amp;#91;:blog.post/id post-id&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This works fine at first, but then a few weeks later you add a new feature to your blogging platform: blog posts can  be annotated with tags. So you add 2 new attributes &lt;code&gt;:blog.post/tags&lt;/code&gt; and &lt;code&gt;:blog.tag/name&lt;/code&gt; to your schema, and you ask  an intern to annotate each of the existing blog posts by hand with some tags. The viewing code now looks like this:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn get-blog-post-as-of
  &amp;quot;Given a database value `db`, blog post id `post-id`, and time `t`,
  returns the version of the blog post as of `t`&amp;quot;
  &amp;#91;db post-id t&amp;#93;
  &amp;#40;d/pull &amp;#40;d/as-of db t&amp;#41;
    '&amp;#91;:blog.post/title
      :blog.post/content
      {:blog.post/tags &amp;#91;:blog.tag/name&amp;#93;}&amp;#93; ;; we just added tags to the query
    &amp;#91;:blog.post/id post-id&amp;#93;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The problem is, if you run this query for a &lt;code&gt;t&lt;/code&gt; that is &lt;em&gt;before&lt;/em&gt; when you transacted the new tag attributes, this won't work! These attributes won't even be in the asOf database, not to mention the data associated with them.&lt;/p&gt;&lt;p&gt;The better way to do this would be to reify the versions of blog posts explicitly in your schema as &lt;em&gt;revision entities&lt;/em&gt;, e.g:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn get-blog-post-as-of
  &amp;quot;Given a database value `db`, blog post id `post-id`, and time `t`,
  returns the version of the blog post as of `t`&amp;quot;
  &amp;#91;db post-id t&amp;#93;
  &amp;#40;let &amp;#91;version-t
        &amp;#40;d/q '&amp;#91;:find &amp;#40;max ?t1&amp;#41; . :in $ ?post ?t :where
               &amp;#91;?version :blog.post.version/post ?post&amp;#93;
               &amp;#91;?version :blog.post.version/t ?t1&amp;#93;
               &amp;#91;&amp;#40;&amp;lt;= ?t1 ?t&amp;#41;&amp;#93;&amp;#93;
          db &amp;#91;:blog.post/id post-id&amp;#93; t&amp;#41;
        version-eid
        &amp;#40;d/q '&amp;#91;:find ?version . :in $ ?post ?t1 :where
               &amp;#91;?version :blog.post.version/post ?post&amp;#93;
               &amp;#91;?version :blog.post.version/t ?t1&amp;#93;&amp;#93;
          db &amp;#91;:blog.post/id post-id&amp;#93; version-t&amp;#41;&amp;#93;
    &amp;#40;d/pull db
      '&amp;#91;:blog.post.version/title
        :blog.post.version/content
        {:blog.post.version/tags &amp;#91;:blog.tag/name&amp;#93;}&amp;#93;
      version-eid&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;(Of course, this may not be the most storage-efficient way to represent blog posts - for a serious project, you may want to use a schema   which leverages more structural sharing.)&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;problem&amp;#95;2:&amp;#95;computing&amp;#95;time&amp;#95;series&quot;&gt;&lt;/a&gt;Problem 2: computing time series&lt;/h3&gt;&lt;p&gt;Now imagine you're tracking what users of your blogging platform 'like' what blog posts.  You may want to do this with using a &lt;code&gt;:user/likes-post&lt;/code&gt; attribute.&lt;/p&gt;&lt;p&gt;Now, in order to display some statistics to the author, you want to count how many users have liked a post in a given time interval.  It feels natural to do it using &lt;code&gt;:db/txInstant&lt;/code&gt;:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn count-post-likes-in-interval
  &amp;#91;db post-id t0 t1&amp;#93;
  &amp;#40;-&amp;gt; &amp;#40;d/q '&amp;#91;:find &amp;#40;count ?user&amp;#41; . :in $ ?post ?t0 ?t1 :where
             &amp;#91;?user :user/likes-post ?post ?t&amp;#93;
             &amp;#91;?t :db/txInstant ?time&amp;#93;
             &amp;#91;&amp;#40;&amp;lt;= ?t0 ?time&amp;#41;&amp;#93; &amp;#91;&amp;#40;&amp;lt; ?time ?t1&amp;#41;&amp;#93;&amp;#93;
        db &amp;#91;:blog.post/id post-id&amp;#93; t0 t1&amp;#41;
    &amp;#40;or 0&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This works fine at first, but now imagine you have one of these requirements:&lt;ul&gt;&lt;li&gt;you want to develop an &quot;offline mode&quot; for the mobile client of your platform, in which the likes will be persisted locally and merged back later.&lt;/li&gt;&lt;li&gt;your company acquires another company, and decides to merge their blogging platform in yours, since yours so much better (thanks to Datomic, no doubt).&lt;/li&gt;&lt;/ul&gt;In both cases, it will be impossible for you to import the timing information, since Datomic doesn't let you set &lt;code&gt;:db/txInstant&lt;/code&gt; to a past value.&lt;/p&gt;&lt;p&gt;The better way to do this would be to track the post likes with an explicit instant-typed attribute, for instance:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn count-post-likes-in-interval
  &amp;#91;db post-id t0 t1&amp;#93;
  &amp;#40;-&amp;gt; &amp;#40;d/q '&amp;#91;:find &amp;#40;count ?user&amp;#41; . :in $ ?post ?t0 ?t1 :where
             &amp;#91;?like :like/post ?post&amp;#93; ;; notice how the like now has its own entity
             &amp;#91;?like :like/user ?user&amp;#93;
             &amp;#91;?like :like/time ?time&amp;#93;
             &amp;#91;&amp;#40;&amp;lt;= ?t0 ?time&amp;#41;&amp;#93; &amp;#91;&amp;#40;&amp;lt; ?time ?t1&amp;#41;&amp;#93;&amp;#93;
        db &amp;#91;:blog.post/id post-id&amp;#93; t0 t1&amp;#41;
    &amp;#40;or 0&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a name=&quot;taking&amp;#95;a&amp;#95;step&amp;#95;back:&amp;#95;event&amp;#95;time&amp;#95;vs&amp;#95;recording&amp;#95;time&quot;&gt;&lt;/a&gt;Taking a step back: event time vs recording time&lt;/h2&gt;&lt;p&gt;What just happened here? We've just seen two very tempting uses of &lt;code&gt;db.asOf&amp;#40;&amp;#41;&lt;/code&gt; and &lt;code&gt;:db/txInstant&lt;/code&gt;  which turn out to be prohibitively constraining as your system evolves (schema growth, data migrations, deferred imports, etc.),   because you have very little control over them.  &lt;strong&gt;Datomic does not let you change your mind about the information you encode in its time-travel features,&lt;/strong&gt; and that's usually too big a constraint.&lt;/p&gt;&lt;p&gt;This is not to mean Datomic time-travel features aren't useful - they're extremely valuable for debugging, auditing,  and integrating to other data systems. But you should probably not implement your business logic with them -  in particular, &lt;strong&gt;if your system needs to offer time-related functionality, it should probably not be implemented using Datomic's own time-travel features.&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Of course, I can already here some protests: &lt;em&gt;Wait, I was told Datomic was great for keeping track of time!?&lt;/em&gt;&lt;/p&gt;&lt;p&gt;I think the root of this issue is that we use the word 'time' to denote 2 essentially distinct concepts:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;event time&lt;/strong&gt;: the time at which stuff happened.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;recording time&lt;/strong&gt;: the time at which you're system &lt;em&gt;learns&lt;/em&gt; that stuff happened.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;em&gt;(Disclaimer: this terminology is totally made up by me as I'm writing this.)&lt;/em&gt;&lt;/p&gt;&lt;p&gt;For instance: imagine you're saling on the Atlantic Ocean, in the middle of a storm. At 8:03 AM, a nasty wave wipes the deck clean  and you have to swim back to the boat. At 6:12 PM, you're sitting comfortably in the cabin, writing in the boat's log:  &quot;At 8:03 AM, a nasty wave made me fall from the boat.&quot; 8:03 AM is the event time; 6:12 PM is the recording time.  These are obviously 2 distinct times (which is a good thing, otherwise the boat's log would've ended up in the water).&lt;/p&gt;&lt;p&gt;Datomic, is great at reifying recording time, and giving you leverage over it.  On the other hand, mainstream mutable databases have not really educated us to the distinction between event time and recording time,  because they essentially give you no access to recording time, which makes the notion not very interesting.  Finally, these notions are not specific to Datomic - they probably generalize to any event-sourcing system.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;what&amp;#95;are&amp;#95;datomic&amp;#95;historical&amp;#95;features&amp;#95;good&amp;#95;for&amp;#95;then?&quot;&gt;&lt;/a&gt;What are Datomic historical features good for then?&lt;/h2&gt;&lt;p&gt;In short, they're mostly useful for the generic 'technical housekeeping' of your system:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Preventing information loss:&lt;/strong&gt; you have an easy-to-query archive of every piece of information that was ever saved in your system - and you don't have to anticipate how you're going to leverage it.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Auditing:&lt;/strong&gt; you can know exactly when a piece of information entered your system and how it evolved in it (especially if you're &lt;a href='http://blog.datomic.com/2015/12/reified-transactions.html'&gt;annotating the transactions&lt;/a&gt; in which these changes occurred).&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Debugging:&lt;/strong&gt; you can reproduce the conditions of a bug at the time it happened.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Change detection:&lt;/strong&gt; answering 'what changed' questions, which is very valuable when integrating Datomic to 'derived data' systems.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Having said that, it's not entirely the case that Datomic's time-travel features don't help you manage event time - they do, precisely by preventing information loss.&lt;/p&gt;&lt;p&gt;For instance, let's go back to our 'users like posts' example. Imagine that you've kept track of what users like which posts using the first approach, that is using a single &lt;code&gt;:user/likes-post&lt;/code&gt; attribute. Then you realize you'd like to keep track of when that happens, and therefore migrate to the second approach - that is, using an explicit 'like' entity. Using &lt;code&gt;:db/txInstant&lt;/code&gt;, you will at least be able to keep track of time for the likes you've collected so far - it's a bit hacky and might be inaccurate in some cases, but it's much better than no information at all.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;summary&quot;&gt;&lt;/a&gt;Summary&lt;/h2&gt;&lt;p&gt;If you're new to Datomic, you probably have the same misconceptions as I did regarding the use of Datomic's historical features.&lt;ul&gt;&lt;li&gt;&lt;strong&gt;bad news:&lt;/strong&gt; you've probably over-estimated the usefulness of these features for implementing your own specific time travel. Unless you really know what you're doing, I recommend you don't use &lt;code&gt;db.asOf&amp;#40;&amp;#41;&lt;/code&gt;, &lt;code&gt;db.history&amp;#40;&amp;#41;&lt;/code&gt;, and &lt;code&gt;:db/txInstant&lt;/code&gt; in your business logic code.&lt;/li&gt;&lt;li&gt;&lt;strong&gt;good news:&lt;/strong&gt; you've probably under-estimated the usefulness of these features for managing your entire system as a programmer.&lt;/li&gt;&lt;/ul&gt;I believe the key to getting past this confusion is the distinction between &lt;strong&gt;event time&lt;/strong&gt; (when things happened) and &lt;strong&gt;recording time&lt;/strong&gt; (when your system learns they happened).&lt;/p&gt;&lt;p&gt;Finally, I advise you don't give too much importance to the time-travel features of Datomic - they're just the icing on the cake.  &lt;em&gt;The main benefits of immutability don't arise from time travel; they arise from unlimited consistent reads, locally-scoped changes, easy change detection, and all that can be built on top of them.&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>
Sat, 08 Jul 2017 00:00:00 +0200
</pubDate>
</item>
<item>
<guid>
http://vvvvalvalval.github.io/posts/2016-07-24-datomic-web-app-a-practical-guide.html
</guid>
<link>
http://vvvvalvalval.github.io/posts/2016-07-24-datomic-web-app-a-practical-guide.html
</link>
<title>
Using Datomic in your app: a practical guide
</title>
<description>
&lt;p&gt;&lt;em&gt;Schema rigidity, N+1 problem, impedance mismatch, remote querying, consistency...&lt;/em&gt;  Datomic eliminates many of the biggest problems of traditional databases.  That's how I like to pick technologies: to solve the hard problems for me and leave me the easy ones.  I have been using Datomic professionally for over 8 months now, and I can testify that it's given me a tremendous boost in productivity and quality,  even for ordinary web development tasks.&lt;/p&gt;&lt;p&gt;However, because Datomic is so different from other databases, and because its young ecosystem still lacks convention,  it's taken me some time and thought (at least a week) to come up with an architecture that is practical and lets me leverage its special powers.  My hope is that by reading this post, you'll be able to get started more quickly.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;required&amp;#95;background&quot;&gt;&lt;/a&gt;Required background&lt;/h2&gt;&lt;p&gt;The code samples will be in Clojure, but most of the ideas behind them translate easily to other JVM languages.&lt;/p&gt;&lt;p&gt;I will not dive into the generalities of web development with Clojure; for that, I recommend the &lt;a href='http://www.luminusweb.net/'&gt;Luminus Framework&lt;/a&gt;.  I will only focus on the aspects that are specific to Datomic.&lt;/p&gt;&lt;p&gt;I am assuming that you have basic notions of how Datomic works.  If you don't, I heartedly recommend the &lt;a href='http://www.datomic.com/training.html'&gt;Day of Datomic&lt;/a&gt; training series, as well as the &lt;a href='http://docs.datomic.com/'&gt;official documentation&lt;/a&gt;.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;a&amp;#95;quick&amp;#95;datomic&amp;#95;refresher&quot;&gt;&lt;/a&gt;A quick Datomic refresher&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;In Datomic, the basic unit of information is the &lt;em&gt;datom&lt;/em&gt;,which is a 5-tuple of the form &lt;code&gt;&amp;#91;&amp;lt;entity id&amp;gt; &amp;lt;attribute&amp;gt; &amp;lt;value&amp;gt; &amp;lt;transaction id&amp;gt; &amp;lt;operation&amp;gt;&amp;#93;&lt;/code&gt;, representing a fact. Examples of datoms are &lt;code&gt;&amp;#91;42 :user/email &amp;quot;hello@gmail.com&amp;quot; 201 true&amp;#93;&lt;/code&gt; and &lt;code&gt;&amp;#91;42 :user/friend 42 206 false&amp;#93;&lt;/code&gt;. The &lt;em&gt;transaction id&lt;/em&gt; essentially tells us the time at which the fact was added to the system; the &lt;em&gt;operation&lt;/em&gt; tells us   if we learned the fact or unlearned it.&lt;/li&gt;&lt;li&gt;A Datomic &lt;em&gt;database value&lt;/em&gt; is an immutable, shared data structure that is logically a set of datoms.A database value represents all the knowledge we have at a certain point in time. It's analogous to a &lt;em&gt;commit&lt;/em&gt; in Git.&lt;/li&gt;&lt;li&gt;Database values only grow by accumulating new datoms (there's no 'remove' operation: they do not 'forget' facts).&lt;/li&gt;&lt;li&gt;A Datomic system is a succession of database values. The succession of values is controlled by a process called the Transactor. A Datomic &lt;em&gt;Connection&lt;/em&gt; is a remote &lt;em&gt;reference&lt;/em&gt; to the current database value (similar to a &lt;a href='http://clojure.org/reference/agents'&gt;Clojure Agent&lt;/a&gt;). You can immediately get the current database value from a connection, and you can send writes (called &lt;a href='http://docs.datomic.com/transactions.html'&gt;transaction requests&lt;/a&gt;) asynchronously to the connection.&lt;/li&gt;&lt;li&gt;With Datomic, reading is local, and happens on the application process (which is called a 'Peer'). This is possible because database values are immutable, therefore easy to cache and location-transparent. As a peer queries a database value, it gets lazily loaded and cached into its memory, by chunks (called &lt;em&gt;segments&lt;/em&gt;) so as to avoid many I/O roundtrips to storage.&lt;/li&gt;&lt;li&gt;Datomic provides a low-level reading interface via its &lt;a href='http://docs.datomic.com/indexes.html'&gt;indexes&lt;/a&gt;,  as well 2 high-level reading interfaces on top of it: the &lt;a href='http://docs.datomic.com/query.html'&gt;Datalog&lt;/a&gt; query language and &lt;a href='http://docs.datomic.com/entities.html'&gt;Entities&lt;/a&gt;.&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;business&amp;#95;logic&quot;&gt;&lt;/a&gt;Business Logic&lt;/h2&gt;&lt;h3&gt;&lt;a name=&quot;represent&amp;#95;business&amp;#95;entities&amp;#95;with...&amp;#95;entities&quot;&gt;&lt;/a&gt;Represent business entities with... Entities&lt;/h3&gt;&lt;p&gt;When I was programming with client-server databases, I often asked myself questions like:  &lt;em&gt;Should my function accept an id for this entity? Or should it accept a map representing the entity? If so, what attributes of the entity do I need? What if I need more?&lt;/em&gt; etc.  Obviously there's a balance to be struck between flexibility and performance when  addressing this kind of dilemma, because we're talking about a potentially costly roundtrip to the database server.&lt;/p&gt;&lt;p&gt;With Datomic we don't have this dilemma, because we have Entities. Entities are about as cheap to make as identifiers,  contain as much information as the whole database, and provide a convenient map-like interface.  So the guideline is simple: I always use Entities as the unit of information to communicate between my business logic functions.&lt;/p&gt;&lt;p&gt;For instance, here's a function which finds the comments of a user about a post:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;require '&amp;#91;datomic.api :as d&amp;#93;&amp;#41;

&amp;#40;defn comments-of-user-about-post
  &amp;quot;Given a user Entity and a post Entity, returns the user's comments about that post as a seq of Entities.&amp;quot;
  &amp;#91;user post&amp;#93;
  &amp;#40;let &amp;#91;db &amp;#40;d/entity-db user&amp;#41;&amp;#93;
    &amp;#40;-&amp;gt;&amp;gt; &amp;#40;d/q '&amp;#91;:find &amp;#91;?comment ...&amp;#93; :in $ ?user ?post :where
                &amp;#91;?comment :comment/post ?post&amp;#93;
                &amp;#91;?comment :comment/user ?user&amp;#93;&amp;#93;
           db &amp;#40;:db/id user&amp;#41; &amp;#40;:db/id post&amp;#41;&amp;#41;
     &amp;#40;map #&amp;#40;d/entity db %&amp;#41;&amp;#41;
     &amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;On the whole, I implement business logic using a few categories of functions:&lt;ul&gt;&lt;li&gt;functions that accept entities, and return other entities (like in the example above)&lt;/li&gt;&lt;li&gt;functions that accept entities, and compute a result (e.g a boolean for making a decision, or a number synthesized from an aggregation)&lt;/li&gt;&lt;li&gt;functions that accept entities, and return transaction data (for writing)&lt;/li&gt;&lt;/ul&gt;In addition, at the boundaries of my domain logic, I have functions which convert entities to and from entities, mostly:&lt;ul&gt;&lt;li&gt;&lt;em&gt;finder&lt;/em&gt; functions, accepting a db value and an identifier and returning an entity, e.g &lt;code&gt;&amp;#40;find-user-by-id db #uuid&amp;quot;57062d44-8829-4776-af3a-2fdf4d7ce93a&amp;quot;&amp;#41;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;em&gt;clientizer&lt;/em&gt; functions, accepting an entity and returning a data structure (typically a plain old map) which can be sent over the network (typically to the  client), serialized as JSON or Transit for example. Here's an example of clientizer function: &lt;span class=&quot;sn&quot;&gt;advanced Datomic users may find this implementation uselessly verbose. Depending on the contract between your server and your client, you may be able to write a much more concise implementation using Datomic's Pull API; you may even not need clientizer functions at all!&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn cl-comment
  &amp;quot;clientizes a comment.&amp;quot;
  &amp;#91;cmt&amp;#93;
  {:id &amp;#40;:comment/id cmt&amp;#41;
   :content &amp;#40;:comment/content cmt&amp;#41;
   :author {:id &amp;#40;-&amp;gt; cmt :comment/author :user/id&amp;#41;}
   :post {:id &amp;#40;-&amp;gt; cmt :comment/post :post/id&amp;#41;}}&amp;#41;
 &lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;Don't forget that in Datomic the database is effectively local, so you don't have the N+1 problem.  This means you can feel free to handle a request by doing many simple queries instead of one big query. &lt;strong&gt;&lt;i&gt;A query is not an expedition.&lt;/i&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;For example, imagine you want to make a Compojure REST endpoint that fetches the comments of a user about a specific post. Because you want to save network roundtrips to database storage, you may write it as:&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; BAD
&amp;#40;GET &amp;quot;/posts/:postId/comments-of-user/:userId&amp;quot;
  &amp;#91;postId userId :as req&amp;#93;
  &amp;#40;let &amp;#91;db &amp;#40;:db req&amp;#41;&amp;#93;
    {:body &amp;#40;-&amp;gt;&amp;gt;
             ;; big hairy query, which complects resources identification, domain logic, and result layout
             &amp;#40;d/q '&amp;#91;:find ?id ?content ?userId ?postId
                    :in $ ?userId ?postId :where
                    ;; resources identification
                    &amp;#91;?user :user/id ?userId&amp;#93;
                    &amp;#91;?post :post/id ?postId&amp;#93;
                    ;; domain logic
                    &amp;#91;?comment :comment/post ?post&amp;#93;
                    &amp;#91;?comment :comment/author ?user&amp;#93;
                    ;; result layout
                    &amp;#91;?comment :comment/id ?id&amp;#93;
                    &amp;#91;?comment :comment/content ?content&amp;#93;
                    &amp;#93;
               db userId postId&amp;#41;
             &amp;#40;map &amp;#40;fn &amp;#91;&amp;#91;id content userId postId&amp;#93;&amp;#93;
                    {:id id
                     :content content
                     :author {:id userId}
                     :post {:id postId}}&amp;#41;&amp;#41;&amp;#41;}&amp;#41;&amp;#41;
 &lt;/code&gt;&lt;/pre&gt; Obviously this is not great for code reuse. Well, you don't have to do that. Instead, you can compose the simple functions we have defined above and just write:&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; GOOD
&amp;#40;GET &amp;quot;/posts/:postId/comments-of-user/:userId&amp;quot;
  &amp;#91;postId userId :as req&amp;#93;
  &amp;#40;let &amp;#91;db &amp;#40;:db req&amp;#41;
        ;; resources identification
        user &amp;#40;find-user-by-id db userId&amp;#41;
        post &amp;#40;find-post-by-id db postId&amp;#41;&amp;#93;
    {:body &amp;#40;-&amp;gt;&amp;gt; &amp;#40;comments-of-user-about-post user post&amp;#41; ;; domain logic
             &amp;#40;map cl-comment&amp;#41; ;; result layout
             &amp;#41;}&amp;#41;&amp;#41;
 &lt;/code&gt;&lt;/pre&gt; There are many queries involved here, but there will be very few roundtrips to storage, typically one or two, and maybe zero if the relevant segments are already cached on the Peer.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;querying:&amp;#95;datalog&amp;#95;vs&amp;#95;entities.&quot;&gt;&lt;/a&gt;Querying: Datalog vs Entities.&lt;/h3&gt;&lt;p&gt;&lt;div style=&quot;text-align:center;&quot;&gt;&lt;img src=&quot;/img/DATALOG-VS-ENTITIES.jpg&quot; width=&quot;400px&quot;&gt;&lt;/div&gt;&lt;/p&gt;&lt;p&gt;Datomic gives you 2 main mechanisms for querying: Entities and Datalog queries. They're very complementary; feel free to mix and match them!&lt;ul&gt;&lt;li&gt;Datalog works though pattern recognition in the database graph. It has its own constructs for control flow and abstraction, and is useful for expressing domain logic via declarative rules.&lt;/li&gt;&lt;li&gt;Entities are useful for 'navigating' around in your database, using your programming language for control flow and abstraction.&lt;/li&gt;&lt;/ul&gt;Additionally, both Datalog and Entities can be combined with the &lt;a href='http://docs.datomic.com/pull.html'&gt;Pull API&lt;/a&gt;, giving you a powerful, declarative, data-oriented way of formatting the results of a query.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;schema&amp;#95;/&amp;#95;model&amp;#95;declaration&quot;&gt;&lt;/a&gt;Schema / model declaration&lt;/h2&gt;&lt;p&gt;Before you can add useful data to Datomic, you need to &lt;em&gt;install your schema&lt;/em&gt;, which specifies the set of attributes that represent your domain model in Datomic.&lt;/p&gt;&lt;p&gt;In Datomic, installing your schema consists of submitting a regular transaction. Attribute installation transactions are idempotent,  so you can just write your schema installation transaction in your application code and &lt;code&gt;transact&lt;/code&gt; in your server startup code.&lt;/p&gt;&lt;p&gt;Here's an example of a schema installation transaction, representing a Person entity with id, email and name fields:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns myapp.model
  &amp;#40;:require &amp;#91;datomic.api :as d&amp;#93;&amp;#41;&amp;#41;

&amp;#40;def schema
  &amp;#91;{:db/id &amp;#40;d/tempid :db.part/db&amp;#41;
    :db/ident :person/name
    :db/valueType :db.type/uuid
    :db/unique :db.unique/identity
    :db/doc &amp;quot;A person's unique id&amp;quot;
    :db/cardinality :db.cardinality/one
    :db.install/&amp;#95;attribute :db.part/db}
   {:db/id &amp;#40;d/tempid :db.part/db&amp;#41;
    :db/ident :person/email
    :db/valueType :db.type/string
    :db/doc &amp;quot;A person's email address&amp;quot;
    :db/fulltext true
    :db/cardinality :db.cardinality/one
    :db.install/&amp;#95;attribute :db.part/db}
   {:db/id &amp;#40;d/tempid :db.part/db&amp;#41;
    :db/ident :person/name
    :db/valueType :db.type/string
    :db/doc &amp;quot;A person's name&amp;quot;
    :db/fulltext true
    :db/cardinality :db.cardinality/one
    :db.install/&amp;#95;attribute :db.part/db}&amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is a &lt;a href='http://stackoverflow.com/questions/31416378/recommended-way-to-declare-datomic-schema-in-clojure-application'&gt;variety of opinions&lt;/a&gt; on how you should declare and install your schema, but in my view we have 2 issues here:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Issue 1: there's a lot of noise; ideally we'd like to spend 1 LoC on each attribute, not 7.&lt;/li&gt;&lt;li&gt;Issue 2: it's &lt;em&gt;only&lt;/em&gt; useful for Datomic schema installation, whereas you may want to declare a schema for your data model for other purposes   (input validation, documentation, REST endpoints generation, plumatic Schemas, test.check generators, etc.).  In other words, when implementing these other aspects of your data model, you'll be to duplicating code to some extent.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;There are several libraries which tackle these issues; some are just concise DSLs on top of Datomic schema transactions,  while others take care of more things (but are also more opinionated):&lt;ul&gt;&lt;li&gt;&lt;a href='https://github.com/Yuppiechef/datomic-schema'&gt;datomic-schema&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/cloojure/tupelo-datomic'&gt;tupelo-datomic&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/SparkFund/spec-tacular'&gt;spec-tacular&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href='https://github.com/zcaudate/adi'&gt;adi&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;The general idea is always the same: have a DSL generate a high-level data structure representing your data model, then &lt;em&gt;derive&lt;/em&gt; your Datomic schema installation transactions (and other things) from this data structure.&lt;/p&gt;&lt;p&gt;Personally, none of these libraries satisfied me completely for my use case, so I wrote up my own little DSL for dealing with Issue 1  (it's not hard, really, you can totally get away with it).  I've been coping with Issue 2 so far without too much trouble - it's a pain, but really not what I spend most time on.  So really, see what works for you.  &lt;span class=&quot;sn&quot;&gt;Some Datomic users prefer keeping the schema in raw EDN-form,  arguing that the operational advantage of having the schema in a static file in transactable-form with no dependencies outweighs the inconvenience of it being verbose.  Datomic creators made the great call of designing Datomic schemas to be data-oriented and query-able, giving the users maximum flexibility in how they declare and deploy them.  You should choose the approach that suits you best for you use case and personal taste.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;In this regard, you may be wondering:&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;where's&amp;#95;my&amp;#95;orm?&quot;&gt;&lt;/a&gt;Where's my ORM?&lt;/h3&gt;&lt;p&gt;&lt;em&gt;(If you're definitely not interested in ORMs, you may skip this section).&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Well, first off, you have to consider that Clojure is not Object-oriented, and that Datomic is not Relational (in the sense that data  is not structured as relations, which is a fancy name for tables). So much for O and R.&lt;/p&gt;&lt;p&gt;However, this doesn't mean that you wouldn't want to perform a Mapping of some sort. One of goals of ORMs is to let you use constructs of  your programming language. What with Entities and the Pull API, Datomic already goes a long way to facilitate that.&lt;/p&gt;&lt;p&gt;Another feature of ORMs is to address other issues with your data, such as validation (see 'Issue 2' above).  Datomic doesn't provide anything to help you do that.&lt;/p&gt;&lt;p&gt;If that's an issue, you may even want to roll out your own mapping library.  Implementing ORMs is knowingly difficult, but Clojure/Datomic Mapping should be significantly easier that Object/Relational Mapping,  because many of the fundamental issues of SQL databases and Object-Oriented languages simply don't exist in these technologies:&lt;/p&gt;&lt;ol&gt;&lt;li&gt;The database is immutable and not remote, which eliminates most of the thorny distributed systems / concurrency issues you would face when implementing an ORM for a client-server database.&lt;/li&gt;&lt;li&gt;The impedance mismatch between Datomic databases and Clojure data structures is &lt;em&gt;much&lt;/em&gt; smaller than the impedance mismatch between relations and objects.&lt;/li&gt;&lt;li&gt;The DDL of Datomic is first-class data, which you can run query against and annotate as much as you want.&lt;/li&gt;&lt;li&gt;You're not constrained by a class system for declaring schemas, so you can use the syntax and information model you want.&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;(Don't be too eager to go down that road though. Chances are you'll be &lt;em&gt;fine&lt;/em&gt; with just Datomic)&lt;/p&gt;&lt;p&gt;ORMs tend to be frowned upon in the Clojure community, because existing ORM implementations are so incompatible with the idea of simplicity,  because they encourage terrible distributed system semantics,  and probably also because many the Java Enterprise veterans of the community had a traumatic experience with them.&lt;/p&gt;&lt;p&gt;However, I do believe that some of the appeal of ORMs is valid.  Maybe what's missing in this space is a generic, extensible way to declare your schemas and derive behaviour from them,  and I might eventually come up with a library that lets you do it à la carte. Stay tuned.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;data&amp;#95;migrations&quot;&gt;&lt;/a&gt;Data Migrations&lt;/h2&gt;&lt;p&gt;Part of database management is ensuring your database schema evolves in sync with your application code.&lt;/p&gt;&lt;p&gt;As we've seen, adding an attribute (the equivalent of adding a column or table is SQL) is straightforward.  You can just reinstall your whole schema at deployment time. Same thing for &lt;a href='http://docs.datomic.com/database-functions.html'&gt;database functions&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;Modifying an attribute (e.g changing the type of &lt;code&gt;:person/id&lt;/code&gt; from &lt;code&gt;:db.type/uuid&lt;/code&gt; to &lt;code&gt;:db.type/string&lt;/code&gt;) is more problematic,  and I suggest you do your best to avoid it. Try to get your schema right in the first place; experiment with it in the  in-memory connection before committing it to durable storage. If you have committed it already, consider versioning the attribute  (e.g &lt;code&gt;:person.v2/id&lt;/code&gt;).&lt;/p&gt;&lt;p&gt;You probably won't ever need to delete an attribute. Just stop using it in your application code.  Optionally, you can mark an attribute as deprecated:&lt;ul&gt;&lt;li&gt;by updating its documentation, e.g &lt;code&gt;:db/doc &amp;quot;DEPRECATED - use :person/firstName and :person/lastName instead. A person's name&amp;quot;&lt;/code&gt;&lt;/li&gt;&lt;li&gt;by adding a home-made deprecation attribute (e.g &lt;code&gt;:attr/deprecated&lt;/code&gt;) &lt;em&gt;to the attribute itself&lt;/em&gt;, since Datomic attributes are themselves entities.&lt;/li&gt;&lt;/ul&gt;Finally, you will sometimes need to run a migration that does not consist of modifying the schema, but the data itself (fixing badly formatted data, adding a default value of a new attribute, etc.).  You want to run these migrations exactly once at deployment time.  The strategy for that is:&lt;ol&gt;&lt;li&gt;write a transaction function for your migration&lt;/li&gt;&lt;li&gt;keep track of what transaction have already been run in the database&lt;/li&gt;&lt;li&gt;have a generic transaction function that conditionally runs another transaction only if it has not already been run&lt;/li&gt;&lt;li&gt;at deployment time, send your migration transactions wrapped by the generic transaction function to the transactor.  This way the transactional features of Datomic take care of the coordination for you.&lt;/li&gt;&lt;/ol&gt;Note that there's a library called &lt;a href='https://github.com/rkneufeld/conformity'&gt;Conformity&lt;/a&gt; which takes care of 2, 3 and 4 for you.&lt;/p&gt;&lt;p&gt;As an example, imagine that you realize you stored all of your user's email addresses without controlling the case,  and you want to convert them to lower case.&lt;/p&gt;&lt;p&gt;You will add this transaction function to your schema:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;{:db/id &amp;#40;d/tempid :db.part/user&amp;#41;
 :db/ident :myapp.fns.migrations/lowercase-user-emails
 :db/fn &amp;#40;d/function
          {:lang &amp;quot;clojure&amp;quot;
           :params '&amp;#91;db&amp;#93;
           :requires '&amp;#40;&amp;#91;datomic.api :as d&amp;#93;
                       &amp;#91;clojure.string :as str&amp;#93;&amp;#41;
           :code '&amp;#40;for &amp;#91;&amp;#91;user email&amp;#93; &amp;#40;d/q '&amp;#91;:find ?user ?email :where
                                            &amp;#91;?user :user/email ?email&amp;#93;&amp;#93;
                                       db&amp;#41;&amp;#93;
                    &amp;#91;:db/add user :user/email &amp;#40;str/lower-case email&amp;#41;&amp;#93;&amp;#41;}&amp;#41;}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then the transaction that runs your migration is simply:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#91;&amp;#91;myapp.fns.migrations/lowercase-user-emails&amp;#93;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The generic transaction function for conditionnaly running migrations may look like the following:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#91;{:db/id &amp;#40;d/tempid :db.part/user&amp;#41;
  :db/ident :run-tx-if-necessary
  :db/doc &amp;quot;runs the given named transaction if it has not already been run.&amp;quot;
  :db/fn &amp;#40;d/function
           {:lang &amp;quot;clojure&amp;quot;
            :params '&amp;#91;db migr-name tx-data&amp;#93;
            :requires '&amp;#40;&amp;#91;datomic.api :as d&amp;#93;&amp;#41;
            :code '&amp;#40;when-not &amp;#40;d/q '&amp;#91;:find ?migr . :in $ ?name :where
                                    &amp;#91;?migr :migration/name ?name&amp;#93;&amp;#93;
                               db migr-name&amp;#41;
                     &amp;#40;concat
                       &amp;#91;&amp;#91;:db/add &amp;#40;d/tempid :db.part/user&amp;#41; :migration/name ?name&amp;#93;&amp;#93;
                       tx-data&amp;#41;&amp;#41;}&amp;#41;}
 {:db/id &amp;#40;d/tempid :db.part/db&amp;#41;
  :db/ident :migration/name
  :db/valueType :db.type/string
  :db/unique :db.unique/identity
  :db/doc &amp;quot;Support attribute for :run-tx-if-necessary&amp;quot;
  :db/cardinality :db.cardinality/one
  :db.install/&amp;#95;attribute :db.part/db}&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then conditionally running the migration simply consists of transacting the following:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#91;&amp;#91;:run-tx-if-necessary &amp;quot;lowercase-user-emails&amp;quot; &amp;#91;&amp;#91;myapp.fns.migrations/lowercase-user-emails&amp;#93;&amp;#93;&amp;#93;&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Again, if you're using Comformity, you needn't concern yourself with that. This is just to give you an idea of how it works.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;testing&amp;#95;and&amp;#95;development&amp;#95;workflow&quot;&gt;&lt;/a&gt;Testing and development workflow&lt;/h2&gt;&lt;p&gt;A significant part of the leverage you get from using Clojure and Datomic is the testing and interactive development stories. These are not trivial to get right, so you need to plan your architecture and workflow for them. Hopefully I've done most of the work for you.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;fixture&amp;#95;data&quot;&gt;&lt;/a&gt;Fixture data&lt;/h3&gt;&lt;p&gt;If you're doing example-based testing, you're going to need some example data for your tests to work on, aka &lt;em&gt;fixture data&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;Simply have a namespace where you write your fixtures as Datomic transactions, which will be run when your create your Datomic connection for testing or development.&lt;/p&gt;&lt;p&gt;You'll also want to expose some stable identifiers so that your test code can find the particular entities that interest them in the fixtures.&lt;/p&gt;&lt;p&gt;Example:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;ns myapp.fixtures
  &amp;#40;:require &amp;#91;datomic.api :as d&amp;#93;&amp;#41;&amp;#41;

&amp;#40;def person1-id #uuid&amp;quot;579ef389-525e-4017-bdd7-3eebb4a1f484&amp;quot;&amp;#41;
&amp;#40;def person2-id #uuid&amp;quot;579ef39b-13af-4acd-b3c9-3fb63a42d2ef&amp;quot;&amp;#41;

&amp;#40;def persons
  &amp;#91;{:person/id person1-id
    :person/email &amp;quot;person1@gmail.com&amp;quot;
    :person/name &amp;quot;Odysseus&amp;quot;
    :db/id &amp;#40;d/tempid :db.part/user&amp;#41;}
   {:person/id person2-id
    :person/email &amp;quot;person2@gmail.com&amp;quot;
    :person/name &amp;quot;Calliope&amp;quot;
    :db/id &amp;#40;d/tempid :db.part/user&amp;#41;}&amp;#93;&amp;#41;

;; &amp;#91;...&amp;#93;

&amp;#40;defn tx-fixtures
  &amp;quot;Returns a transaction which installs all the fixture data.&amp;quot;
  &amp;#91;&amp;#93;
  &amp;#40;concat
    persons
    ;; &amp;#91;...&amp;#93;
    &amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;creating&amp;#95;in-memory&amp;#95;connections&quot;&gt;&lt;/a&gt;Creating in-memory connections&lt;/h3&gt;&lt;p&gt;The next thing we need is a way to obtain an in-memory Datomic connection with all the schema and fixture data installed.&lt;/p&gt;&lt;p&gt;Here's an implementation, which we'll modify slightly when we learn about forking connections.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;require '&amp;#91;datomic.api :as d&amp;#93;&amp;#41;
&amp;#40;require '&amp;#91;myapp.schema :as mysc&amp;#93;&amp;#41;
&amp;#40;require '&amp;#91;myapp.fixtures :as fix&amp;#93;&amp;#41;

&amp;#40;defn scratch-conn
  &amp;quot;Creates an in-memory Datomic connection.
  NOTE: we actually won't be using this implementation, see next section on forking connections.&amp;quot;
  &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;uri &amp;#40;str &amp;quot;datomic:mem://&amp;quot; &amp;quot;mem-conn-&amp;quot; &amp;#40;d/squuid&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;d/create-database uri&amp;#41;
    &amp;#40;d/connect uri&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn fixture-conn
  &amp;quot;Creates a Datomic connection with the schema and fixture data installed.&amp;quot;
  &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;conn &amp;#40;scratch-conn&amp;#41;&amp;#93;
    @&amp;#40;d/transact conn &amp;#40;mysc/tx-schema&amp;#41;&amp;#41;
    @&amp;#40;d/transact conn &amp;#40;fix/tx-fixtures&amp;#41;&amp;#41;
    conn&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;forking&amp;#95;database&amp;#95;connections&quot;&gt;&lt;/a&gt;Forking database connections&lt;/h3&gt;&lt;p&gt;So now we have connections that we can use for development and testing. That's a good start, but in their current form they can be impractical:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;if you run a test case which does writes, and want to go back to a fresh state, you'll need to explicitly release the current connection and make a new one;&lt;/li&gt;&lt;li&gt;on my dev laptop, running &lt;code&gt;&amp;#40;fixture-conn&amp;#41;&lt;/code&gt; takes about 300 ms to create the database and install the schema and fixture.  If you plan on running dozens or hundreds of tests, this can feel really slow.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Fortunately, a few months ago I discovered that you can use one of Datomic's superpowers, &lt;em&gt;speculative writes&lt;/em&gt; (aka &lt;a href='http://docs.datomic.com/clojure/#datomic.api/with'&gt;db.with()&lt;/a&gt;),  to implement an &lt;em&gt;fork&lt;/em&gt; operation on Datomic connections.  I could talk at length about forking connections (and I do it &lt;a href='http://vvvvalvalval.github.io/posts/2016-01-03-architecture-datomic-branching-reality.html'&gt;here&lt;/a&gt;); in a nutshell, forking a connection is the ability to  create a new, local connection which holds the same current database value as the old connection, but will evolve independently  of the old connection afterwards.&lt;/p&gt;&lt;p&gt;Forking connections solves both our problems because:&lt;ul&gt;&lt;li&gt;you don't need to do any manual resource reclamation; forked connections will just be garbage-collected when you're done with them.&lt;/li&gt;&lt;li&gt;forking is completely inexpensive in time and space (the overhead is that of creating a Clojure Atom).&lt;/li&gt;&lt;/ul&gt;This changes the way we obtain a mock connection: instead of creating a connection from scratch on each test case, we'll create a &lt;em&gt;starting-point&lt;/em&gt; connection once, and then &lt;em&gt;fork&lt;/em&gt; it to obtain a fresh connection for each test case.&lt;/p&gt;&lt;p&gt;I've implemented a tiny library called &lt;a href='https://github.com/vvvvalvalval/datomock'&gt;datomock&lt;/a&gt; which implements this fork operation.  It also implements the equivalent of &lt;code&gt;scratch-conn&lt;/code&gt;, so our previous code becomes:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;require '&amp;#91;datomic.api :as d&amp;#93;&amp;#41;
&amp;#40;require '&amp;#91;datomock.core :as dm&amp;#93;&amp;#41;
&amp;#40;require '&amp;#91;myapp.schema :as mysc&amp;#93;&amp;#41;
&amp;#40;require '&amp;#91;myapp.fixtures :as fix&amp;#93;&amp;#41;

&amp;#40;defn make-fixture-conn
  &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;conn &amp;#40;dm/mock-conn&amp;#41;&amp;#93;
    @&amp;#40;d/transact conn &amp;#40;mysc/tx-schema&amp;#41;&amp;#41;
    @&amp;#40;d/transact conn &amp;#40;fix/tx-fixtures&amp;#41;&amp;#41;
    conn&amp;#41;&amp;#41;

&amp;#40;def starting-point-conn &amp;#40;make-fixture-conn&amp;#41;&amp;#41;

&amp;#40;defn fixture-conn
  &amp;quot;Creates a Datomic connection with the schema and fixture data installed.&amp;quot;
  &amp;#91;&amp;#93;
  &amp;#40;dm/fork-conn starting-point-conn&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;(we'll make one more tiny change to this code in the next section. It'll be the last one, I promise!)&lt;p&gt;Forking Datomic connections has other benefits.  For instance, forking your production connection enables you to instantly reproduce the state of your production system on your local machine.  That's very handy for debugging, or if you need to make a manual modification to your data and want to &quot;rehearse&quot; it locally before  committing it to the production database.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;auto-reloading&amp;#95;tests&amp;#95;and&amp;#95;fixture&amp;#95;freshness&quot;&gt;&lt;/a&gt;Auto-reloading tests and fixture freshness&lt;/h3&gt;&lt;p&gt;We still have a problem with the above code: it works fine for running your test suite once or starting a local server, but it's not compatible with interactive development.&lt;/p&gt;&lt;p&gt;Whether you're running your tests in the REPL or using a auto-reloading test runner like Midje, whenever you make changes to your schema or fixture code, &lt;code&gt;starting-point-conn&lt;/code&gt; won't get updated automatically, and your tests won't reflect your last code changes.&lt;/p&gt;&lt;p&gt;We solve this using the oldest magic trick of Computer Science: time-based caching! Instead of storing our &lt;code&gt;starting-point-conn&lt;/code&gt; in a Var, we'll cache it with a Time To Live of a few seconds.&lt;/p&gt;&lt;p&gt;If you're using the Google Guava library you can use their in-memory cache directly, otherwise it's easy enough to make your own with an Atom and the core.cache library.&lt;/p&gt;&lt;p&gt;So finally, here's the &lt;strong&gt;whole&lt;/strong&gt; code for creating in-memory connections:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;require '&amp;#91;clojure.core.cache :as cache&amp;#93;&amp;#41;
&amp;#40;require '&amp;#91;datomic.api :as d&amp;#93;&amp;#41;
&amp;#40;require '&amp;#91;datomock.core :as dm&amp;#93;&amp;#41;
&amp;#40;require '&amp;#91;myapp.schema :as mysc&amp;#93;&amp;#41;
&amp;#40;require '&amp;#91;myapp.fixtures :as fix&amp;#93;&amp;#41;

&amp;#40;defn make-fixture-conn
  &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;conn &amp;#40;dm/mock-conn&amp;#41;&amp;#93;
    @&amp;#40;d/transact conn &amp;#40;mysc/tx-schema&amp;#41;&amp;#41;
    @&amp;#40;d/transact conn &amp;#40;fix/tx-fixtures&amp;#41;&amp;#41;
    conn&amp;#41;&amp;#41;

&amp;#40;defonce conn-cache
  &amp;#40;atom &amp;#40;cache/ttl-cache-factory {} :ttl 5000&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn starting-point-conn &amp;#91;&amp;#93;
  &amp;#40;:conn &amp;#40;swap! conn-cache #&amp;#40;if &amp;#40;cache/has? % :conn&amp;#41;
                             &amp;#40;cache/hit % :conn&amp;#41;
                             &amp;#40;cache/miss % :conn &amp;#40;make-fixture-conn&amp;#41;&amp;#41;&amp;#41;
           &amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn fixture-conn
  &amp;quot;Creates a Datomic connection with the schema and fixture data installed.&amp;quot;
  &amp;#91;&amp;#93;
  &amp;#40;dm/fork-conn &amp;#40;starting-point-conn&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;a name=&quot;environments&quot;&gt;&lt;/a&gt;Environments&lt;/h3&gt;&lt;p&gt;In my day-to-day work, the environments I use are:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;'local': in-memory Datomic instance with fixture data.&lt;/li&gt;&lt;li&gt;'dev': Datomic instance on my local machine with real-world data (typically a dump of my production instance).&lt;/li&gt;&lt;li&gt;'prod': Datomic connection of my production system&lt;/li&gt;&lt;li&gt;'dev-fork': fork of the 'dev' Datomic instance, so that I can work on real-world data without persisting anything.&lt;/li&gt;&lt;li&gt;'prod-fork': fork of my production Datomic instance, when I need to work on up-to-date data locally&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;In practice, the environments I use most are 'local', 'dev-fork' and 'prod-fork'.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;misc&quot;&gt;&lt;/a&gt;Misc&lt;/h2&gt;&lt;p&gt;Here are some last tips:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;If you have ClojureScript on the client, don't forget to have a look at the &lt;a href='https://github.com/omcljs/om/wiki#om-next'&gt;Om Next architecture&lt;/a&gt;. It's very straightforward to implement with Datomic and the Pull API, and it can save you a lot of work and trouble compared to  setting up a REST architecture.&lt;/li&gt;&lt;li&gt;Check out &lt;a href='https://github.com/tonsky/datascript'&gt;Datascript&lt;/a&gt;, which can make it easy to sync data between Datomic and the client.&lt;/li&gt;&lt;li&gt;One technique that's often useful is &lt;em&gt;attribute sharing&lt;/em&gt;: share an attribute across several entity types. For instance, if there are several entity types for which you want to track the creation time, you may want to have a generic &lt;code&gt;:time/created&lt;/code&gt; attribute, instead of 2 attributes &lt;code&gt;:post/created&lt;/code&gt; and &lt;code&gt;:comment/created&lt;/code&gt;. (There are ways in which you can abuse this approach, just know that it's a possibility).&lt;/li&gt;&lt;li&gt;Write your own lib! The Datomic ecosystem is still young, and Datomic is pretty uniquely extensible via libraries. It's completely okay to write a few helper functions to make your interactions with Datomic more convenient. Think of Datomic as a great &lt;em&gt;foundation&lt;/em&gt; for your database needs.&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;conclusion&quot;&gt;&lt;/a&gt;Conclusion&lt;/h2&gt;&lt;p&gt;I hope you've found this useful, if there's anything that's unclear or missing in this post feel free to comment.  Have fun with Datomic!&lt;/p&gt;
</description>
<pubDate>
Sun, 24 Jul 2016 00:00:00 +0200
</pubDate>
</item>
<item>
<guid>
http://vvvvalvalval.github.io/posts/2016-01-03-architecture-datomic-branching-reality.html
</guid>
<link>
http://vvvvalvalval.github.io/posts/2016-01-03-architecture-datomic-branching-reality.html
</link>
<title>
Application architecture with Datomic: branching reality
</title>
<description>
&lt;p&gt;&lt;div style=&quot;text-align:center;&quot;&gt;&lt;img src=&quot;/img/multiverse.jpg&quot; width=&quot;300px&quot;&gt;&lt;/div&gt;&lt;/p&gt;&lt;p&gt;In this post, I'll present an architectural pattern for structuring Clojure and Datomic apps, playing a similar role  to Dependency Injection in the Object-Oriented world.&lt;/p&gt;&lt;p&gt;The big picture is that your application logic manipulates &lt;em&gt;universes&lt;/em&gt;, which are mutable programmatic values with a &lt;code&gt;fork&lt;/code&gt; operation, which essentially makes 2 diverging universes out of one. This 'fork' abstraction is analogous to forking branches in Git, and is made possible using one of Datomic's special powers: speculative writes.&lt;/p&gt;&lt;p&gt;I've found this approach to make system-level tests very straightforward to write, and to play nicely with interactive development. Read on for more details.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;universes&quot;&gt;&lt;/a&gt;Universes&lt;/h2&gt;&lt;p&gt;Any but the most trivial application needs some way to separate configuration from use. Some examples:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;if your application is backed by a database, you'll want your application code to use a connection to your test database in a test environment,and a connection to your production database in a production environment.&lt;/li&gt;&lt;li&gt;if your application needs to send emails, for instance using a web service like Mandrill, you'll want to use a test Mandrill token  during development and tests, and a real Mandrill token in production.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;These requirements are well-known, and have been traditionally addressed in class-based languages like Java using 'Inversion of Control Patterns' like &lt;em&gt;Dependency Injection&lt;/em&gt; and &lt;em&gt;Service Locator&lt;/em&gt;.&lt;/p&gt;&lt;p&gt;In Clojure, there are no classes, so it's tempting to simply use global Vars to store configuration:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;require '&amp;#91;datomic.api :as d&amp;#93;&amp;#41;

;; configuration
&amp;#40;def conn &amp;quot;the Datomic connection&amp;quot;
  &amp;#40;d/connect &amp;#40;System/getProperty &amp;quot;DATOMIC&amp;#95;URI&amp;quot;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;def mandrill-token &amp;quot;the token for authenticating to the Mandrill API&amp;quot;
  &amp;#40;System/getProperty &amp;quot;MANDRILL&amp;#95;TOKEN&amp;quot;&amp;#41;&amp;#41;


;; business logic
&amp;#40;defn some-business-logic &amp;#91;x y&amp;#93;
  &amp;#40;d/transact conn &amp;#40;make-some-transaction-using x :and y ...&amp;#41;&amp;#41;
  &amp;#40;send-mandrill-email! mandrill-token &amp;#40;make-some-email-with x :and y ...&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Please, never do this. This is global state and environment coupling at the same time. It will make your tests harder to write, ruin your REPL experience, and complect the lifecycle of your application with the loading of its code. Bad, bad, bad.&lt;/p&gt;&lt;p&gt;Another tempting idea is to use dynamic Vars, one of Clojure's special features, to mitigate the above-mentioned issues:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;require '&amp;#91;datomic.api :as d&amp;#93;&amp;#41;

;; configuration
&amp;#40;def &amp;#94;:dynamic conn &amp;quot;the Datomic connection&amp;quot; nil&amp;#41;

&amp;#40;def &amp;#94;:dynamic mandrill-token &amp;quot;the token for authenticating to the Mandrill API&amp;quot; nil&amp;#41;


;; business logic
&amp;#40;defn some-business-logic &amp;#91;x y&amp;#93;
  &amp;#40;d/transact conn &amp;#40;make-some-transaction-using x :and y ...&amp;#41;&amp;#41;
  &amp;#40;send-mandrill-email! mandrill-token &amp;#40;make-some-email-with x :and y ...&amp;#41;&amp;#41;&amp;#41;

;; starting the application
&amp;#40;defn start-app! &amp;#91;&amp;#93;
  &amp;#40;binding &amp;#91;conn &amp;#40;d/connect &amp;#40;System/getProperty &amp;quot;DATOMIC&amp;#95;URI&amp;quot;&amp;#41;&amp;#41;
            mandrill-token &amp;#40;System/getProperty &amp;quot;MANDRILL&amp;#95;TOKEN&amp;quot;&amp;#41;&amp;#93;
    ...&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I don't recommend this either. This is still environment coupling, even if you have an easier way to control the environment. You may also find yourself typing thse annoying &lt;code&gt;&amp;#40;binding ...&amp;#41;&lt;/code&gt; clauses all the time in the REPL, which kind of defeats the purpose of using Vars.&lt;/p&gt;&lt;p&gt;It is now an &lt;a href='https://github.com/stuartsierra/component'&gt;established best practice&lt;/a&gt; in the Clojure community to pass the configuration as additional arguments to your business logic functions,  making them self-contained. For example, you can pass the configuration values as a map&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn some-business-logic &amp;#91;{:keys &amp;#91;conn mandrill-token&amp;#93;} x y&amp;#93;
  &amp;#40;d/transact conn &amp;#40;make-some-transaction-using x :and y ...&amp;#41;&amp;#41;
  &amp;#40;send-mandrill-email! mandrill-token &amp;#40;make-some-email-with x :and y ...&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Where does the configuration map come from? It depends on your application. For instance, if your application is an HTTP server with a Ring adapter, the &lt;code&gt;-main&lt;/code&gt; function could create the configuration map from  environment properties at startup, then listen to the HTTP port and 'attach' the configuration map to each incoming request.&lt;/p&gt;&lt;p&gt;This 'configuration map' could also be called a 'context' or 'environment', but I want to call it a &lt;em&gt;universe&lt;/em&gt;, for reasons which will become more obvious later.&lt;/p&gt;&lt;p&gt;What makes a universe? Here are some examples of what you might put in this configuration map:&lt;ul&gt;&lt;li&gt;database connections&lt;/li&gt;&lt;li&gt;API tokens and other configuration constants&lt;/li&gt;&lt;li&gt;application services as protocol implementations (so that you may mock them), e.g Ring session-stores&lt;/li&gt;&lt;li&gt;if you're using Datomic, the current database value&lt;/li&gt;&lt;li&gt;the present time (never use &lt;code&gt;&amp;#40;new java.util.Date&amp;#41;&lt;/code&gt;, that's environment coupling too!)&lt;/li&gt;&lt;/ul&gt;The mental model is that your application logic is made of stateless, configuration-free, timeless components which manipulate the universe (&lt;em&gt;any universe&lt;/em&gt;) in response to events.In contrast, with Dependency Injection, I would say that your application components are created inside and configured by a universe.&lt;/p&gt;&lt;p&gt;In testing, universes will tend to be made out of test database connections and mocked services. After all, that's the idea behind making mocks for testing: fabricating a small, isolated universe in which we can mess around without affecting the &lt;em&gt;real&lt;/em&gt; universe, the one our business cares about.&lt;/p&gt;&lt;p&gt;Hold that thought. We'll make a small detour in Datomic Land to get some reality-branching superpowers, then come back to universes,  at which point things will get more interesting.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;lemma:&amp;#95;mocking&amp;#95;datomic&amp;#95;connections&quot;&gt;&lt;/a&gt;Lemma: mocking Datomic connections&lt;/h2&gt;&lt;p&gt;Datomic supports &lt;em&gt;speculative writes&lt;/em&gt;, in the form of its &lt;code&gt;datomic.api/with&lt;/code&gt; function. Roughly speaking, &lt;code&gt;with&lt;/code&gt; accepts a database value and a write specification, and returns an updated database value &lt;em&gt;as if&lt;/em&gt; you had sent a transaction to the connection.&lt;/p&gt;&lt;p&gt;Therefore, it's useful to answer &quot;what if&quot; questions. But we can go further and abuse &lt;code&gt;with&lt;/code&gt; to mock Datomic connections in-memory. Here is a complete implementation, which is essentially an Atom holding database values, which uses &lt;code&gt;with&lt;/code&gt; for writes (&lt;strong&gt;edit:&lt;/strong&gt; you can now use the &lt;a href='https://github.com/vvvvalvalval/datomock'&gt;datomock library&lt;/a&gt;):&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;import 'datomic.Connection&amp;#41;
&amp;#40;import '&amp;#40;java.util.concurrent BlockingQueue LinkedBlockingDeque&amp;#41;&amp;#41;
&amp;#40;require 'datomic.promise&amp;#41;
&amp;#40;require '&amp;#91;datomic.api :as d&amp;#93;&amp;#41;

&amp;#40;defrecord MockConnection
  &amp;#91;dbAtom, &amp;#94;BlockingQueue txQueue&amp;#93;

  Connection
  &amp;#40;db &amp;#91;this&amp;#93; @dbAtom&amp;#41;
  &amp;#40;transact &amp;#91;this tx-data&amp;#93; &amp;#40;doto &amp;#40;datomic.promise/settable-future&amp;#41;
                             &amp;#40;deliver &amp;#40;let &amp;#91;tx-res
                                            &amp;#40;loop &amp;#91;&amp;#93;
                                              &amp;#40;let &amp;#91;old-val @dbAtom
                                                    tx-res &amp;#40;d/with old-val tx-data&amp;#41;
                                                    new-val &amp;#40;:db-after tx-res&amp;#41;&amp;#93;
                                                &amp;#40;if &amp;#40;compare-and-set! dbAtom old-val new-val&amp;#41;
                                                  tx-res
                                                  &amp;#40;recur&amp;#41;&amp;#41;
                                                &amp;#41;&amp;#41;&amp;#93;
                                        &amp;#40;.add &amp;#94;BlockingQueue txQueue tx-res&amp;#41;
                                        tx-res&amp;#41;&amp;#41;
                             &amp;#41;&amp;#41;
  &amp;#40;transactAsync &amp;#91;this tx-data&amp;#93; &amp;#40;.transact this tx-data&amp;#41;&amp;#41;

  &amp;#40;gcStorage &amp;#91;this olderThan&amp;#93;&amp;#41;
  &amp;#40;requestIndex &amp;#91;this&amp;#93;&amp;#41;
  &amp;#40;release &amp;#91;this&amp;#93;&amp;#41;
  &amp;#40;sync &amp;#91;this&amp;#93; &amp;#40;doto &amp;#40;datomic.promise/settable-future&amp;#41;
                 &amp;#40;deliver &amp;#40;.db this&amp;#41;&amp;#41;&amp;#41;&amp;#41;
  &amp;#40;syncExcise &amp;#91;this t&amp;#93; &amp;#40;.sync this&amp;#41;&amp;#41;
  &amp;#40;syncIndex &amp;#91;this t&amp;#93; &amp;#40;.sync this&amp;#41;&amp;#41;
  &amp;#40;syncSchema &amp;#91;this t&amp;#93; &amp;#40;.sync this&amp;#41;&amp;#41;
  &amp;#40;sync &amp;#91;this t&amp;#93; &amp;#40;.sync this&amp;#41;&amp;#41;
  &amp;#40;txReportQueue &amp;#91;this&amp;#93; &amp;#40;.txQueue this&amp;#41;&amp;#41;

  &amp;#41;

&amp;#40;defn &amp;#94;Connection mock-conn
  &amp;quot;Creates a mocked version of datomic.Connection which uses db/with internally.
  Only supports datomic.api/db, datomic.api/transact and datomic.api/transact-async operations.
  Sync and housekeeping methods are implemented as noops. #log&amp;#40;&amp;#41; is not supported.&amp;quot;
  &amp;#91;db&amp;#93;
  &amp;#40;MockConnection. &amp;#40;atom db&amp;#41; &amp;#40;LinkedBlockingDeque.&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You may be wondering, how is this different than using Datomic's built-in in-memory connections ? (as in &lt;code&gt;&amp;#40;d/connect &amp;quot;datomic:mem://my-db-name&amp;quot;&amp;#41;&amp;#41;&lt;/code&gt;) Well, Datomic's in-memory connections start with a blank database, whereas in the above implementation the user provides a &lt;em&gt;starting-point database&lt;/em&gt;. This starting point might be a database loaded with fixture data; it might also be your current production database!&lt;/p&gt;&lt;p&gt;In particular, you can use these mock connections to make a local 'fork' of any Datomic connection:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn &amp;#94;Connection fork-conn
  &amp;quot;Creates a local fork of the given Datomic connection.
  Writes to the forked connection will not affect the original;
  conversely, writes to the original connection will not affect the forked one.&amp;quot;
  &amp;#91;conn&amp;#93;
  &amp;#40;mock-conn &amp;#40;d/db conn&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;Analogy to Git:&lt;/strong&gt; This is the same notion of forking as in Git, where database values are like commits, and connections are like branches.  (However, unlike Git, there is no 'merge' operation).&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;forking&amp;#95;universes&quot;&gt;&lt;/a&gt;Forking universes&lt;/h2&gt;&lt;p&gt;This notion of forking is interesting, and applicable to other objects than Datomic connections. For example, immutable data structures and simple mutable interfaces (e.g HTTP session stores) can be forked too.&lt;/p&gt;&lt;p&gt;Which brings us to the main point: &lt;strong&gt;if the universes of your application have Datomic as their main data store, then you can &lt;em&gt;fork&lt;/em&gt; these universes&lt;/strong&gt;.&lt;/p&gt;&lt;p&gt;&lt;em&gt;Forking&lt;/em&gt; a universe is making a local 'copy' of a universal which behaves exactly as the original one, in which you can mess around without affecting the original one.&lt;/p&gt;&lt;p&gt;This is of tremendous value for system-level testing. Because of functional programming, Clojure already has a great story for testing &lt;em&gt;in the small&lt;/em&gt;, but in the large, your system is essentially a process which performs in-place updates in response to events. Forkable connections are a nice fit for this model. Forget about your setup and teardown phases: instead, you have a &lt;em&gt;starting point&lt;/em&gt; universe,  and for each of your tests which involves writes, you simply fork off another universe, perform your tests, and forget about it when you're done.  Garbage collection will do the cleaning up for you.&lt;/p&gt;&lt;p&gt;For instance, imagine you have an e-commerce website, and you want to test the purchase flow. The purchase flow consists of the user signing up, verifying her account, adding items to the cart, and checking out. Typically, the test will consist of one ideal scenario, and several scenarios where things go wrong, like the cart expiring or the user logging out before checking out. You can easily test this by branching off several universes matching different scenarios as you progress along the user path:&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/img/funnel-purchase.png&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;&lt;p&gt;The code for testing this may look like the following:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;let &amp;#91;u &amp;#40;fork starting-point-universe&amp;#41;&amp;#93;
  &amp;#40;create-account! u&amp;#41;

  &amp;#40;let &amp;#91;u &amp;#40;fork u&amp;#41;&amp;#93;
    &amp;#40;expect-to-fail
      &amp;#40;add-items-to-cart! u some-items-data&amp;#41;&amp;#41;&amp;#41;

  &amp;#40;verify-account! u&amp;#41;

  &amp;#40;let &amp;#91;u &amp;#40;fork u&amp;#41;&amp;#93;
    &amp;#40;expect-to-fail
      &amp;#40;add-items-to-cart! u sold-out-items-data&amp;#41;&amp;#41;&amp;#41;

  &amp;#40;add-items-to-cart! u some-items-data&amp;#41;

  &amp;#40;let &amp;#91;u &amp;#40;fork u&amp;#41;&amp;#93;
    &amp;#40;expect-to-fail
      &amp;#40;log-out! u&amp;#41;
      &amp;#40;pay-and-check-out! u&amp;#41;&amp;#41;&amp;#41;

  &amp;#40;let &amp;#91;u &amp;#40;assoc &amp;#40;fork u&amp;#41;
            :now &amp;#40;after-the-cart-has-expired&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;expect-to-fail
      &amp;#40;pay-and-check-out! u&amp;#41;&amp;#41;&amp;#41;

  &amp;#40;expect-to-succeed
    &amp;#40;pay-and-check-out! u&amp;#41;&amp;#41;
  &amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Forkable universes also offer a lot of leverage of interactive development. Sometimes I want to work in my development environment with my production data, but without committing any change to my production database;  this is useful for experimenting with new features, or for demonstration purposes.  All I have to is fork my production context and run my local server on it.&lt;/p&gt;&lt;p&gt;I can also imagine automating the above idea to make &quot;inspection tests&quot;, in which you would periodically simulate some scenarios on your production data.&lt;/p&gt;&lt;p&gt;Finally, I think forkability makes room for some REPL-friendly debugging techniques.  For example, you can insert 'checkpoints' in a code path you're debugging, which when reached will make forks of the current universe and store them.  You can then retrieve these checkpoints to inspect the past of the universe, or to replay some steps manually.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;about&amp;#95;mutability&quot;&gt;&lt;/a&gt;About mutability&lt;/h2&gt;&lt;p&gt;Universes are essentially about mutability and side-effects, which may seem at odds with the functional spirit of Clojure and Datomic. That's not the case in my opinion, since Clojure positioned itself &lt;a href='http://www.infoq.com/presentations/Value-Identity-State-Rich-Hickey'&gt;since the beginning&lt;/a&gt; as supporting mutability in the few places where it is a better fit than a purely functional style.&lt;/p&gt;&lt;p&gt;Having said that, universes and the ability to fork them are no excuse to make a mutable imperative mess. You still want to make the building blocks of your application purely functional, on as large a scale as is reasonable.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;forkability,&amp;#95;and&amp;#95;clojure's&amp;#95;time&amp;#95;model&quot;&gt;&lt;/a&gt;Forkability, and Clojure's time model&lt;/h2&gt;&lt;p&gt;The &lt;em&gt;Epochal Time Model&lt;/em&gt; embodied in Clojure and Datomic consists of an &lt;em&gt;identity&lt;/em&gt; (represented e.g by a Datomic connection, an Atom, ...) which &lt;em&gt;state&lt;/em&gt; changes over time as a succession of values (e.g Datomic database values, persistent data structures, ...): &quot;the state is the value of an identity at a point in time&quot;. In this model, changing the state means setting the state of an identity to a new value.&lt;/p&gt;&lt;p&gt;Interestingly, &lt;em&gt;forking&lt;/em&gt; also has a natural interpretation in this time model: duplicating an identity without changing its state.  (at least that's the way I see it).&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;practical&amp;#95;usage&quot;&gt;&lt;/a&gt;Practical usage&lt;/h2&gt;&lt;p&gt;I have a test namespace with a function to create 'starting-point universe' loaded with fixture data. This function is called by tests, and by me from the REPL. Because loading the database schema and fixture data can take some time (~100ms), I back this function with a TTL cache of a few seconds. This allows me to never have a stale context as my code evolves, while not wasting time on a heavy setup phase for each test.&lt;/p&gt;&lt;p&gt;On top of that, I have a dev namespace with 2 functions &lt;code&gt;fu&lt;/code&gt; (&lt;em&gt;Fresh Universe&lt;/em&gt;) and &lt;code&gt;lu&lt;/code&gt; (&lt;em&gt;Local Universe&lt;/em&gt;). Both return universes with fixture data, but &lt;code&gt;fu&lt;/code&gt; returns a different universe each time it is called (stateless), whereas &lt;code&gt;lu&lt;/code&gt; creates a universe the first time and then returns it (session); there is an optional param to reset the universe returned by &lt;code&gt;lu&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;To achieve full universe forkability, I also had to make mock implementations of a few key-value stores in addition to Datomic, such as Ring session stores.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;parting&amp;#95;thoughts&quot;&gt;&lt;/a&gt;Parting thoughts&lt;/h2&gt;&lt;p&gt;I am constantly amazed to see how immutability, although it encourages functional programming, also makes dealing with side-effects and mutable places better. This is a lesson we have learned in the small with Clojure's references, and now we're learning it in the large with Datomic.&lt;/p&gt;&lt;p&gt;At &lt;a href='https://www.bandsquare.com'&gt;BandSquare&lt;/a&gt; we have applied the above ideas to our whole backend system, to great benefits so far. We will continue to explore the possibilities and limitations of forkable universes, and we welcome your feedback.&lt;/p&gt;&lt;p&gt;Happy New Year!&lt;/p&gt;
</description>
<pubDate>
Sun, 03 Jan 2016 00:00:00 +0100
</pubDate>
</item>
<item>
<guid>
http://vvvvalvalval.github.io/posts/2015-09-16-bottup-approach-to-reagent-state.html
</guid>
<link>
http://vvvvalvalval.github.io/posts/2015-09-16-bottup-approach-to-reagent-state.html
</link>
<title>
A bottom-up approach to state in Reagent
</title>
<description>
&lt;p&gt;In this post, I'll present an alternative way of managing state in Reagent applications to what is currently made popular by libraries like &lt;a href='https://github.com/Day8/re-frame'&gt;Re-frame&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;tl;dr&quot;&gt;&lt;/a&gt;TL;DR&lt;/h2&gt;&lt;p&gt;We'll be able to declare 'local state' inside our Reagent components, which feels like ephemeral local atoms but is accessible globally and is Figwheel-reloadable.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;End result&lt;/strong&gt; : &lt;iframe src=&quot;https://player.vimeo.com/video/139510973&quot; width=&quot;100%&quot; height=&quot;330&quot; frameborder=&quot;0&quot; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;&lt;p&gt;(watch it in HD &lt;a href=&quot;https://vimeo.com/139510973&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;)&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;rationale&quot;&gt;&lt;/a&gt;Rationale&lt;/h2&gt;&lt;p&gt;From what I have seen, the currently most popular approach to state management in Reagent applications is to have one global Reactive Atom and to centralize the behaviour for updating this Ratom.&lt;/p&gt;&lt;p&gt;I completely agree that this approach is very sound for a large space of applications; it also has the advantage of making your code &lt;a href='https://github.com/bhauman/lein-figwheel#writing-reloadable-code'&gt;Figwheel-reloadable&lt;/a&gt; out of the box.&lt;/p&gt;&lt;p&gt;However, I do believe this approach has its limitations. Basing everything on a global ratom encourages your components to leverage a lot of context, making them less 'portable'. More importantly, I find this forces you to have a top-down approach to state management: you need to design the whole schema for your app state, and account for everything that could happen to it from the very start.&lt;/p&gt;&lt;p&gt;Sometimes, I feel I do not want this. Instead, I want my components to behave not as partial views of some global state, but as 'micro-applications', managing their own state instead of deferring this to some global decision maker. I like the idea that my components are autonomous, and can just be plugged into their parents without much knowledge of their context. This is what I call a &lt;em&gt;bottom-up&lt;/em&gt; approach to state management. &lt;span class=&quot;sn&quot;&gt;This is about the only way of doing things in libraries like AngularJS, in which directives just have local state and are meant to be autonomous. What I find great in Reagent is that I can combine both approaches.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;In this post, I'll present a way of achieving this, while retaining some of the great benefits of the top-down approach.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;requirements&quot;&gt;&lt;/a&gt;Requirements&lt;/h2&gt;&lt;p&gt;Our goal is to abide by the following requirements :&lt;/p&gt;&lt;ol&gt;&lt;li&gt;We want to make Reagent components with local state. In particular, the lifecycle of this local state is bound to the lifecycle of the component: it gets initialized when the component mounts, it gets cleaned up when the component unmounts.&lt;/li&gt;&lt;li&gt;We want this local state managed by the component, not externally&lt;/li&gt;&lt;li&gt;This 'local state' is actually perceptible from the global Reactive Atom of our app. This way, our system has the 'all state in one place' property, a.k.a 'email me your state and I'll see exactly what you see'.&lt;/li&gt;&lt;li&gt;This local state is &lt;em&gt;reloadable&lt;/em&gt;, i.e when we are developing with Figwheel, we don't have to re-create this state each time we make a code change.&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;&lt;a name=&quot;the&amp;#95;traditional&amp;#95;approach&amp;#95;to&amp;#95;local-state&amp;#95;in&amp;#95;reagent&quot;&gt;&lt;/a&gt;The traditional approach to local-state in Reagent&lt;/h2&gt;&lt;p&gt;As we can learn from the &lt;a href='https://reagent-project.github.io/'&gt;project page&lt;/a&gt;, the traditional way of making components with local state is as follows:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;instead of writing a rendering function, you write a 'wrapper' function which &lt;em&gt;returns&lt;/em&gt; a rendering function.&lt;/li&gt;&lt;li&gt;the 'wrapper' function initializes some local state in the form of ratoms stored in locals of the wrapper function&lt;/li&gt;&lt;li&gt;the rendering function just closes over these locals and uses them.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;This is all very neat and intuitive, but it does not quite comply to our requirements : it's not reachable from our global state ratom, and it's not figwheel-reloadable.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;strategy&quot;&gt;&lt;/a&gt;Strategy&lt;/h2&gt;&lt;p&gt;Here is how we'll implement this :&lt;/p&gt;&lt;ul&gt;&lt;li&gt;we still have a unique global ratom, which will hold &lt;em&gt;all the state&lt;/em&gt; of the application (including component-local state)&lt;/li&gt;&lt;li&gt;instead of creating local ratoms, stateful components will be handed a 'location' (a Cursor) in the global state where to put their local state.&lt;/li&gt;&lt;li&gt;they will initialize this local state when they mount, and clean it when they unmount&lt;/li&gt;&lt;li&gt;we'll also need some tricks to make this robust to figwheel code reloads.&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;a name=&quot;example&quot;&gt;&lt;/a&gt;Example&lt;/h2&gt;&lt;p&gt;I'll demonstrate this with a very poor, ugly version of TODO MVC.&lt;/p&gt;&lt;p&gt;Let's first lay out the 'model' of our app:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;require '&amp;#91;reagent.core :as r&amp;#93;&amp;#41;

;; this atom holds the global state, we use `defonce` to make it reloadable
&amp;#40;defonce todo-state-atom &amp;#40;r/atom {:todos &amp;#91;&amp;#93;}&amp;#41;&amp;#41;

;; here's a little helper to generate unique ids
&amp;#40;defonce next-id &amp;#40;atom 0&amp;#41;&amp;#41;
&amp;#40;defn gen-id &amp;#91;&amp;#93; &amp;#40;swap! next-id inc&amp;#41;&amp;#41;

;; these 3 functions are for manipulating the state
&amp;#40;defn add-todo &amp;#91;todo-state&amp;#93; &amp;#40;update todo-state :todos conj {:id &amp;#40;gen-id&amp;#41; :text &amp;quot;&amp;quot;}&amp;#41;&amp;#41;

&amp;#40;defn delete-todo &amp;#91;todo-state {:keys &amp;#91;id&amp;#93;}&amp;#93;
  &amp;#40;update todo-state :todos &amp;#40;fn &amp;#91;todos&amp;#93; &amp;#40;-&amp;gt;&amp;gt; todos &amp;#40;remove #&amp;#40;= &amp;#40;:id %&amp;#41; id&amp;#41;&amp;#41; vec&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn update-todo &amp;#91;todo-state {:keys &amp;#91;id&amp;#93; :as todo}&amp;#93;
  &amp;#40;update todo-state :todos &amp;#40;fn &amp;#91;todos&amp;#93; &amp;#40;-&amp;gt;&amp;gt; todos &amp;#40;map #&amp;#40;if &amp;#40;= &amp;#40;:id %&amp;#41; id&amp;#41; todo %&amp;#41;&amp;#41; vec&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now, let's see how to implement the view.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;the&amp;#95;traditional&amp;#95;way:&amp;#95;with&amp;#95;old&amp;#95;fashioned&amp;#95;locals&quot;&gt;&lt;/a&gt;The traditional way: with old fashioned locals&lt;/h3&gt;&lt;p&gt;As a reference for comparison, we'll start by implementing it the 'traditional' Reagent way : with local ratoms to hold the local state.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; ... and here's our UI :
&amp;#40;declare &amp;lt;todos-list&amp;gt; &amp;lt;todo-item&amp;gt;&amp;#41;

&amp;#40;defn &amp;lt;todos-list&amp;gt; &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;update-me! #&amp;#40;swap! todo-state-atom update-todo %&amp;#41;
        delete-me! #&amp;#40;swap! todo-state-atom delete-todo %&amp;#41;&amp;#93;
    &amp;#91;:div.container
     &amp;#91;:h2 &amp;quot;TODO&amp;quot;&amp;#93;
     &amp;#91;:ul
      &amp;#40;for &amp;#91;todo &amp;#40;:todos @todo-state-atom&amp;#41;&amp;#93;
        &amp;#94;{:key &amp;#40;:id todo&amp;#41;} &amp;#91;&amp;lt;todo-item&amp;gt; todo update-me! delete-me!&amp;#93;
        &amp;#41;&amp;#93;
     &amp;#91;:button.btn.btn-success {:on-click #&amp;#40;swap! todo-state-atom add-todo&amp;#41;} &amp;quot;Add&amp;quot;&amp;#93;

     &amp;#91;:div
      &amp;#91;:h2 &amp;quot;State&amp;quot;&amp;#93;
      &amp;#91;:pre &amp;#40;with-out-str &amp;#40;pprint/pprint @todo-state-atom&amp;#41;&amp;#41;&amp;#93;&amp;#93;&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn &amp;lt;todo-item&amp;gt; &amp;#91;{:keys &amp;#91;id&amp;#93;} update-me! delete-me!&amp;#93;
  &amp;#40;let &amp;#91;local-state &amp;#40;r/atom {:editing false}&amp;#41;&amp;#93;
    &amp;#40;fn &amp;#91;{:keys &amp;#91;id text&amp;#93; :as todo} update-me! delete-me!&amp;#93;
      &amp;#40;if &amp;#40;:editing @local-state&amp;#41;
        &amp;#91;:li
         &amp;#91;:span &amp;quot;type in some awesome text :&amp;quot;&amp;#93;
         &amp;#91;:input {:type &amp;quot;text&amp;quot; :value text :on-change #&amp;#40;update-me! &amp;#40;assoc todo :text &amp;#40;-&amp;gt; % .-target .-value&amp;#41;&amp;#41;&amp;#41;}&amp;#93;
         &amp;#91;:button {:on-click #&amp;#40;swap! local-state assoc :editing false&amp;#41;} &amp;quot;Done&amp;quot;&amp;#93;&amp;#93;
        &amp;#91;:li
         &amp;#91;:span &amp;quot;text: &amp;quot; text&amp;#93;
         &amp;#91;:button {:on-click #&amp;#40;swap! local-state assoc :editing true&amp;#41;} &amp;quot;Edit&amp;quot;&amp;#93;
         &amp;#91;:button {:on-click #&amp;#40;delete-me! todo&amp;#41;} &amp;quot;Remove&amp;quot;&amp;#93;&amp;#93;&amp;#41;
      &amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is the most straightforward way of doing things, but as we said earlier, it does not yield an optimal result: the local state is not reachable from the global atom, not does it survive code reloads. Let's make this better.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;the&amp;#95;new&amp;#95;way:&amp;#95;with&amp;#95;managed&amp;#95;cursors&quot;&gt;&lt;/a&gt;The new way: with managed cursors&lt;/h3&gt;&lt;p&gt;We'll store the local state in cursors of the global ratom, instead of ratoms stored in locals.&lt;/p&gt;&lt;p&gt;Of course, now that we're not using locals, we can no longer rely on garbage collection to clean up after us, so we have to do it explicitly using lifecycle methods.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; in this cursor, we'll put the local state of each list item
&amp;#40;defonce todos-state-cursor &amp;#40;r/cursor todo-state-atom &amp;#91;:todo-state&amp;#93;&amp;#41;&amp;#41;

&amp;#40;declare &amp;lt;todos-list&amp;gt; &amp;lt;todo-item&amp;gt; &amp;lt;todo-item-plugged&amp;gt;&amp;#41;

&amp;#40;defn &amp;lt;todos-list&amp;gt; &amp;#91;&amp;#93;
  &amp;#40;let &amp;#91;update-me! #&amp;#40;swap! todo-state-atom update-todo %&amp;#41;
        delete-me! #&amp;#40;swap! todo-state-atom delete-todo %&amp;#41;&amp;#93;
    &amp;#91;:div.container
     &amp;#91;:h2 &amp;quot;TODO&amp;quot;&amp;#93;
     &amp;#91;:ul
      &amp;#40;for &amp;#91;todo &amp;#40;:todos @todo-state-atom&amp;#41;&amp;#93;
        &amp;#94;{:key &amp;#40;:id todo&amp;#41;} &amp;#91;&amp;lt;todo-item&amp;gt; todos-state-cursor todo update-me! delete-me!&amp;#93;
        &amp;#41;&amp;#93;
     &amp;#91;:button.btn.btn-success {:on-click #&amp;#40;swap! todo-state-atom add-todo&amp;#41;} &amp;quot;Add&amp;quot;&amp;#93;

     &amp;#91;:div
      &amp;#91;:h2 &amp;quot;State&amp;quot;&amp;#93;
      &amp;#91;:pre &amp;#40;with-out-str &amp;#40;pprint/pprint @todo-state-atom&amp;#41;&amp;#41;&amp;#93;&amp;#93;&amp;#93;&amp;#41;&amp;#41;

&amp;#40;defn &amp;lt;todo-item&amp;gt; &amp;#91;parent-atom {:keys &amp;#91;id&amp;#93;} update-me! delete-me!&amp;#93;
  &amp;#40;let &amp;#91;local-state-cursor &amp;#40;r/cursor parent-atom &amp;#91;id&amp;#93;&amp;#41;&amp;#93;
    &amp;#40;r/create-class
      {:component-will-mount &amp;#40;fn &amp;#91;&amp;#95;&amp;#93; &amp;#40;when-not @local-state-cursor ;; setting up
                                       &amp;#40;reset! local-state-cursor {:editing false}&amp;#41;&amp;#41;&amp;#41;
       :component-will-unmount &amp;#40;fn &amp;#91;&amp;#95;&amp;#93; &amp;#40;swap! parent-atom dissoc id&amp;#41;&amp;#41; ;; cleaning up
       :reagent-render
       &amp;#40;fn &amp;#91;parent-atom {:keys &amp;#91;id text&amp;#93; :as todo} update-me! delete-me!&amp;#93;
         &amp;#40;if &amp;#40;:editing @local-state-cursor&amp;#41;
           &amp;#91;:li
            &amp;#91;:span &amp;quot;type in some awesome text :&amp;quot;&amp;#93;
            &amp;#91;:input {:type &amp;quot;text&amp;quot; :value text :on-change #&amp;#40;update-me! &amp;#40;assoc todo :text &amp;#40;-&amp;gt; % .-target .-value&amp;#41;&amp;#41;&amp;#41;}&amp;#93;
            &amp;#91;:button {:on-click #&amp;#40;swap! local-state-cursor assoc :editing false&amp;#41;} &amp;quot;Done&amp;quot;&amp;#93;&amp;#93;
           &amp;#91;:li
            &amp;#91;:span &amp;quot;text: &amp;quot; text&amp;#93;
            &amp;#91;:button {:on-click #&amp;#40;swap! local-state-cursor assoc :editing true&amp;#41;} &amp;quot;Edit&amp;quot;&amp;#93;
            &amp;#91;:button {:on-click #&amp;#40;delete-me! todo&amp;#41;} &amp;quot;Remove&amp;quot;&amp;#93;&amp;#93;&amp;#41;
         &amp;#41;}&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We have now full visibility of the whole state of our app, and can manipulate all of it using the REPL. This is a big improvement.&lt;/p&gt;&lt;p&gt;However, we haven't achieved reloadability yet. Let's see how it goes.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;making&amp;#95;it&amp;#95;reloadable&quot;&gt;&lt;/a&gt;Making it reloadable&lt;/h3&gt;&lt;p&gt;This is kind of tricky.&lt;/p&gt;&lt;p&gt;In order to reload the code, our app has to be re-mounted into the DOM on each code reload. I'm using the &lt;a href='https://github.com/bhauman/figwheel-template'&gt;figwheel Leiningen template&lt;/a&gt;, which does it by calling a &lt;code&gt;mount-root&lt;/code&gt; function on each reload :&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn mount-root &amp;#91;&amp;#93;
  &amp;#40;r/render &amp;#91;&amp;lt;todos-list&amp;gt;&amp;#93; &amp;#40;.getElementById js/document &amp;quot;app&amp;quot;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The problem is, each time a new version gets mounted, the old version gets unmounted. As a consequence, the &lt;code&gt;:component-will-unmount&lt;/code&gt; function we defined above is called, and diligently erases our local state.&lt;/p&gt;&lt;p&gt;We need to find a way of informing our component that the unmounting is caused by a Figwheel reload, so that it does not erase its state. This is made harder by the fact that mounting happens asynchronously.&lt;/p&gt;&lt;p&gt;The best way I've found is to set up a flag when the reloading happens, and leave it up long enough that the DOM can mount :&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defonce reloading-state &amp;#40;atom false&amp;#41;&amp;#41; ;; note that we're using a regular atom: the whole point is not to interfere with Reagent here.

&amp;#40;defn reload! &amp;#91;timeout&amp;#93;
  &amp;#40;when timeout
    &amp;#40;reset! reloading-state true&amp;#41;
    &amp;#40;js/setTimeout #&amp;#40;reset! reloading-state false&amp;#41; timeout&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn reloading? &amp;#91;&amp;#93; @reloading-state&amp;#41;

;; ...

&amp;#40;defn mount-root &amp;#91;&amp;#93;
  &amp;#40;reload! 200&amp;#41;
  &amp;#40;r/render &amp;#91;&amp;lt;todos-list&amp;gt;&amp;#93; &amp;#40;.getElementById js/document &amp;quot;app&amp;quot;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can use this by making a tiny change to our component definition :&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn &amp;lt;todo-item&amp;gt; &amp;#91;parent-atom {:keys &amp;#91;id&amp;#93;} update-me! delete-me!&amp;#93;
       ;; ...
       :component-will-unmount &amp;#40;fn &amp;#91;&amp;#95;&amp;#93; &amp;#40;when-not &amp;#40;reloading?&amp;#41;
                                         &amp;#40;swap! parent-atom dissoc id&amp;#41;&amp;#41;&amp;#41;
        ;; ...
       &amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To be honest, I'm not very proud of it, but it works; and given that it only affects our development environment, I don't feel too worried using this little hack.&lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;making&amp;#95;it&amp;#95;less&amp;#95;tedious:&amp;#95;pluggable&amp;#95;components&quot;&gt;&lt;/a&gt;Making it less tedious: pluggable components&lt;/h3&gt;&lt;p&gt;This is great, but it's a pity that we have to resort to lifecycle methods and explicit calls to our &lt;code&gt;&amp;#40;reloading?&amp;#41;&lt;/code&gt; hack every time we want a component with local state, especially since we're using Reagent, which usually excels as hiding away this sort of things.&lt;/p&gt;&lt;p&gt;Fortunately, we can make it more practical. A few weeks ago, I experimented with the concept of so-called (by me) &lt;a href='https://github.com/vvvvalvalval/reagent-pluggable-components-poc'&gt;&amp;#42;pluggable components&amp;#42;&lt;/a&gt;,  which are a way of writing stateful components which have a cleanup phase without writing the same 'lifecyle methods recipes' over and over again.&lt;/p&gt;&lt;p&gt;I won't detail how it works here (although there's &lt;a href='https://github.com/vvvvalvalval/reagent-pluggable-components-poc/blob/master/src/cljs/reagent&amp;#95;plug/core.cljs#L13'&gt;not much&lt;/a&gt; to it), but basically here's the amount of work it takes :&lt;/p&gt;&lt;p&gt;We first define a 'managed cursor' recipe, which encapsulates the 'local cursor lifecycle' logic we coded above :&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defmethod make-plug ::r/managed-cursor &amp;#91;&amp;#91;&amp;#95;&amp;#93; &amp;#91;parent-ratom key&amp;#93;&amp;#93;
  &amp;#40;let &amp;#91;curs &amp;#40;r/cursor parent-ratom &amp;#91;key&amp;#93;&amp;#41;&amp;#93;
    &amp;#40;-&amp;gt;Plug curs #&amp;#40;do nil&amp;#41; #&amp;#40;when-not &amp;#40;reloading?&amp;#41; &amp;#40;swap! parent-ratom dissoc key&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;From now on, we'll be able to reuse this recipe for any stateful component. Let's see how that goes for &lt;code&gt;&amp;lt;todo-item&amp;gt;&lt;/code&gt; :&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn &amp;lt;todos-list&amp;gt; &amp;#91;&amp;#93;
      ;; ...
      &amp;#40;for &amp;#91;todo &amp;#40;:todos @todo-state-atom&amp;#41;&amp;#93;
        ;; the external API for the component is a tiny bit different
        &amp;#94;{:key &amp;#40;:id todo&amp;#41;} &amp;#91;&amp;lt;todo-item&amp;gt; &amp;#91;todos-state-cursor &amp;#40;:id todo&amp;#41;&amp;#93; todo update-me! delete-me!&amp;#93;
        &amp;#41;&amp;#93;
      ;; ...
     &amp;#41;


&amp;#40;defplugged &amp;lt;todo-item&amp;gt;
  &amp;#91;&amp;#40;local-state-cursor &amp;#91;::r/managed-cursor&amp;#93;&amp;#41; ;; `local-state-cursor` gets injected into our component, and will be cleaned up once unmounted
   {:keys &amp;#91;id&amp;#93;} update-me! delete-me!&amp;#93;
  &amp;#40;when-not @local-state-cursor
    &amp;#40;reset! local-state-cursor {:editing false}&amp;#41;&amp;#41;
  &amp;#40;fn &amp;#91;&amp;#95; {:keys &amp;#91;id text&amp;#93; :as todo} update-me! delete-me!&amp;#93;
    &amp;#40;if &amp;#40;:editing @local-state-cursor&amp;#41;
      &amp;#91;:li
       &amp;#91;:span &amp;quot;type in some text : &amp;quot;&amp;#93;
       &amp;#91;:input.form-control {:type &amp;quot;text&amp;quot; :value text :style {:width &amp;quot;100px&amp;quot; :display &amp;quot;inline-block&amp;quot;}
                             :on-change #&amp;#40;update-me! &amp;#40;assoc todo :text &amp;#40;-&amp;gt; % .-target .-value&amp;#41;&amp;#41;&amp;#41;}&amp;#93;
       &amp;quot; &amp;quot;
       &amp;#91;:button.btn.btn-success {:on-click #&amp;#40;swap! local-state-cursor assoc :editing false&amp;#41;} &amp;quot;Done&amp;quot;&amp;#93;&amp;#93;
      &amp;#91;:li
       &amp;#91;:span &amp;quot;text: &amp;quot; text &amp;quot; &amp;quot;&amp;#93;
       &amp;#91;:button.btn.btn-primary {:on-click #&amp;#40;swap! local-state-cursor assoc :editing true&amp;#41;} &amp;quot;Edit&amp;quot;&amp;#93; &amp;quot; &amp;quot;
       &amp;#91;:button.btn.btn-danger {:on-click #&amp;#40;delete-me! todo&amp;#41;} &amp;quot;Remove&amp;quot;&amp;#93;&amp;#93;&amp;#41;
    &amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It's now as lightweight as we'd expect of Reagent!&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;wrapping&amp;#95;up&quot;&gt;&lt;/a&gt;Wrapping up&lt;/h2&gt;&lt;p&gt;I'm very excited about the possibilities of this. We can now have state that feels local, while being reachable and reloadable, with the huge benefits that come with it. Of course, this concept still has to be proven, and this implementation may be suboptimal.&lt;/p&gt;&lt;p&gt;We're getting &lt;a href='https://www.youtube.com/watch?v=PUv66718DII'&gt;there&lt;/a&gt;!&lt;/p&gt;
</description>
<pubDate>
Wed, 16 Sep 2015 00:00:00 +0200
</pubDate>
</item>
<item>
<guid>
http://vvvvalvalval.github.io/posts/2015-09-06-productive-git-setup.html
</guid>
<link>
http://vvvvalvalval.github.io/posts/2015-09-06-productive-git-setup.html
</link>
<title>
Productive Git setup
</title>
<description>
&lt;p&gt;When getting started with Git, you don't always know there exist some trick to make you more productive with it. Here are a few, most of which are already in the &lt;a href='http://git-scm.com/book/en/v1/Git-Basics-Tips-and-Tricks'&gt;official documentation&lt;/a&gt;.&lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;installing&amp;#95;autocompletion&quot;&gt;&lt;/a&gt;Installing autocompletion&lt;/h2&gt; &lt;p&gt;When working with git from the command-line, it's very useful to have autocompletion for your branch/remote names, git commands, etc. Fortunately, there is a bash script for that.  &lt;/p&gt;&lt;p&gt;&lt;!--more--&gt;  &lt;/p&gt;&lt;p&gt;To achieve this, download &lt;a href='https://raw.githubusercontent.com/git/git/master/contrib/completion/git-completion.bash'&gt;this file&lt;/a&gt;, put it under your home directory under the name .git-completion.bash, then reference it from your bash initialization file (either ~/.bash_profile or ~/.bashrc) :  &lt;/p&gt;&lt;pre&gt;&lt;code&gt;source &amp;#126;/.git-completion.bash
&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;&lt;a name=&quot;defining&amp;#95;aliases&quot;&gt;&lt;/a&gt;Defining aliases&lt;/h2&gt; &lt;h3&gt;&lt;a name=&quot;for&amp;#95;common&amp;#95;commands&quot;&gt;&lt;/a&gt;For common commands&lt;/h3&gt; &lt;p&gt;Commands like &lt;code&gt;commit&lt;/code&gt;, &lt;code&gt;branch&lt;/code&gt;, `checkout are so common that it's useful to type them with fewer characters.  To do so, you create git &lt;i&gt;aliases&lt;/i&gt; by typing the following commands in a terminal :  &lt;/p&gt;&lt;pre&gt;&lt;code&gt;git config --global alias.co checkout   
git config --global alias.br branch   
git config --global alias.ci commit   
git config --global alias.st status
&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Once you have done this, you can type co, br, ci, st every time you would normaly type checkout, branch, commit, status.  &lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;to&amp;#95;print&amp;#95;the&amp;#95;commits&amp;#95;graph&quot;&gt;&lt;/a&gt;To print the commits graph&lt;/h3&gt; &lt;p&gt;The following alias will enable you print a pretty representation of the commits graph in your terminal window :&lt;/p&gt;&lt;pre&gt;&lt;code&gt;git config --global alias.lg &amp;quot;log --graph --all --pretty=format:'%C&amp;#40;bold&amp;#41;%h%Creset -%C&amp;#40;auto&amp;#41;%d%Creset %s %C&amp;#40;green dim&amp;#41;&amp;#40;%cr&amp;#41;%Creset %C&amp;#40;ul&amp;#41;&amp;lt;%an&amp;gt;&amp;quot;  
&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Now, typing &lt;code&gt;git lg&lt;/code&gt; in your repository will print something like this :   &lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/img/git-lg-screenshot.png&quot; width=&quot;100%&quot;&gt;  &lt;/p&gt;&lt;p&gt;The effect of setting aliases is to modify your ~/.gitconfig file, which should now look like this :&lt;/p&gt;&lt;pre&gt;&lt;code&gt;   &amp;#91;user&amp;#93;  
       name = Valentin Waeselynck  
       email = val@bandsquare.fr  
  &amp;#91;alias&amp;#93;  
       lg = log --graph --all --pretty=format:'%C&amp;#40;bold&amp;#41;%h%Creset -%C&amp;#40;auto&amp;#41;%d%Creset %s %C&amp;#40;green dim&amp;#41;&amp;#40;%cr&amp;#41;%Creset %C&amp;#40;ul&amp;#41;&amp;lt;%an&amp;gt;'  
       co = checkout  
       br = branch  
       ci = commit  
       st = status  
  &amp;#91;core&amp;#93;  
       editor = vim   
  &amp;#91;filter &amp;quot;media&amp;quot;&amp;#93;  
       clean = git media clean %f  
       smudge = git media smudge %f  
       required = true  
&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;&lt;a name=&quot;using&amp;#95;a&amp;#95;git&amp;#95;gui&amp;#95;client&quot;&gt;&lt;/a&gt;Using a git GUI client&lt;/h2&gt; &lt;p&gt;Working from the command line with the above config is enough for 95% of my everyday work.  But sometimes, I need a better visualisation tool (e.g for diffs) in my local environment, so I also use &lt;a href='https://www.sourcetreeapp.com/'&gt;SourceTree&lt;/a&gt;.&lt;/p&gt;
</description>
<pubDate>
Sun, 06 Sep 2015 00:00:00 +0200
</pubDate>
</item>
<item>
<guid>
http://vvvvalvalval.github.io/posts/2015-09-06-Having-a-good-terminal-console-on-OS-X-in-2015.html
</guid>
<link>
http://vvvvalvalval.github.io/posts/2015-09-06-Having-a-good-terminal-console-on-OS-X-in-2015.html
</link>
<title>
Having a good terminal console on OS X in 2015
</title>
<description>
 &lt;p&gt;As a programmer, your terminal console is part of your everyday life.  That's where you launch your local server, start your database, see your heroku logs, try out that mysterious command you found on some forum, etc.  Don't try to escape it; instead, learn to master it and make it comfortable enough that you feel at home using it.  &lt;/p&gt;&lt;p&gt;My current choice for a terminal on OSX is &lt;a href='http://iterm2.com/'&gt;ITerm2 (official website)&lt;/a&gt;.  &lt;/p&gt;&lt;p&gt;&lt;!--more--&gt;  &lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;installing&amp;#95;iterm2&quot;&gt;&lt;/a&gt;Installing ITerm2&lt;/h2&gt; &lt;p&gt;Nothing tricky here, just download it from the official website.  What you get is a zip archive that unpacks to a .app file. All you have to do is move that file to your Applications folder.  &lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;adding&amp;#95;some&amp;#95;colors&amp;#95;to&amp;#95;the&amp;#95;console&quot;&gt;&lt;/a&gt;Adding some colors to the console&lt;/h2&gt; &lt;p&gt;I like my console to have a dark background because it's easier on the eyes and environment-friendly.  Also I want to see some relevant information like current *nix user and current directory.  &lt;/p&gt;&lt;p&gt;For this I use a little shell script :&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;  # COLORFUL PROMPT  
  # uncomment for a colored prompt, if the terminal has the capability; turned  
  # off by default to not distract the user: the focus in a terminal window  
  # should be on the output of commands, not on the prompt  
  force&amp;#95;color&amp;#95;prompt=yes  
  if &amp;#91; -n &amp;quot;$force&amp;#95;color&amp;#95;prompt&amp;quot; &amp;#93;; then  
    if &amp;#91; -x /usr/bin/tput &amp;#93; &amp;amp;&amp;amp; tput setaf 1 &amp;gt;&amp;amp;/dev/null; then  
      # We have color support; assume it's compliant with Ecma-48  
      # &amp;#40;ISO/IEC-6429&amp;#41;. &amp;#40;Lack of such support is extremely rare, and such  
      # a case would tend to support setf rather than setaf.&amp;#41;  
      color&amp;#95;prompt=yes  
    else  
      color&amp;#95;prompt=  
    fi  
  fi  
  # ANSI color codes  
  RS=&amp;quot;\&amp;#91;\033&amp;#91;0m\&amp;#93;&amp;quot;  # reset  
  HC=&amp;quot;\&amp;#91;\033&amp;#91;1m\&amp;#93;&amp;quot;  # hicolor  
  UL=&amp;quot;\&amp;#91;\033&amp;#91;4m\&amp;#93;&amp;quot;  # underline  
  INV=&amp;quot;\&amp;#91;\033&amp;#91;7m\&amp;#93;&amp;quot;  # inverse background and foreground  
  FBLK=&amp;quot;\&amp;#91;\033&amp;#91;30m\&amp;#93;&amp;quot; # foreground black  
  FRED=&amp;quot;\&amp;#91;\033&amp;#91;31m\&amp;#93;&amp;quot; # foreground red  
  FGRN=&amp;quot;\&amp;#91;\033&amp;#91;32m\&amp;#93;&amp;quot; # foreground green  
  FYEL=&amp;quot;\&amp;#91;\033&amp;#91;33m\&amp;#93;&amp;quot; # foreground yellow  
  FBLE=&amp;quot;\&amp;#91;\033&amp;#91;34m\&amp;#93;&amp;quot; # foreground blue  
  FMAG=&amp;quot;\&amp;#91;\033&amp;#91;35m\&amp;#93;&amp;quot; # foreground magenta  
  FCYN=&amp;quot;\&amp;#91;\033&amp;#91;36m\&amp;#93;&amp;quot; # foreground cyan  
  FWHT=&amp;quot;\&amp;#91;\033&amp;#91;37m\&amp;#93;&amp;quot; # foreground white  
  BBLK=&amp;quot;\&amp;#91;\033&amp;#91;40m\&amp;#93;&amp;quot; # background black  
  BRED=&amp;quot;\&amp;#91;\033&amp;#91;41m\&amp;#93;&amp;quot; # background red  
  BGRN=&amp;quot;\&amp;#91;\033&amp;#91;42m\&amp;#93;&amp;quot; # background green  
  BYEL=&amp;quot;\&amp;#91;\033&amp;#91;43m\&amp;#93;&amp;quot; # background yellow  
  BBLE=&amp;quot;\&amp;#91;\033&amp;#91;44m\&amp;#93;&amp;quot; # background blue  
  BMAG=&amp;quot;\&amp;#91;\033&amp;#91;45m\&amp;#93;&amp;quot; # background magenta  
  BCYN=&amp;quot;\&amp;#91;\033&amp;#91;46m\&amp;#93;&amp;quot; # background cyan  
  BWHT=&amp;quot;\&amp;#91;\033&amp;#91;47m\&amp;#93;&amp;quot; # background white  
  #variables pointing to ANSI color codes  
  USER&amp;#95;CLR=&amp;quot;$RS$HC$FGRN&amp;quot; # the color of the user name, e.g 'val'  
  HOST&amp;#95;CLR=&amp;quot;$RS$FYEL&amp;quot; # the color of the host, e.g 'VVV-SATELLITE-P850'  
  LOC&amp;#95;CLR=&amp;quot;$RS$FGRN&amp;quot; # the color of the location, e.g '&amp;#126;/Documents'  
  MISC&amp;#95;CLR=&amp;quot;$RS$HC$FYEL&amp;quot; # the color of other symbols  
  if &amp;#91; &amp;quot;$color&amp;#95;prompt&amp;quot; = yes &amp;#93;; then  
    #PS1='${debian&amp;#95;chroot:+&amp;#40;$debian&amp;#95;chroot&amp;#41;}\&amp;#91;\033&amp;#91;01;32m\&amp;#93;\u@\h\&amp;#91;\033&amp;#91;00m\&amp;#93;:\&amp;#91;\033&amp;#91;01;34m\&amp;#93;\w\&amp;#91;\033&amp;#91;00m\&amp;#93;\$ '  
    # primary prompt : contains special characters an sequences for additional info about a session.  
    #PS1=&amp;quot;$HC$FYEL&amp;#91; $FBLE${debian&amp;#95;chroot:+&amp;#40;$debian&amp;#95;chroot&amp;#41;}\u$FYEL: $FBLE\w $FYEL&amp;#93;\\$ $RS&amp;quot;  
    PS1=&amp;quot;$HC$MISC&amp;#95;CLR&amp;#91; $USER&amp;#95;CLR\u$HOST&amp;#95;CLR@\h: $LOC&amp;#95;CLR\w $MISC&amp;#95;CLR&amp;#93;\n$USER&amp;#95;CLR\\$ $RS&amp;quot;  
    # secondary prompt shows just '&amp;gt;'  
    PS2=&amp;quot;$HC$FYEL&amp;gt; $RS&amp;quot;  
  else  
    #PS1='${debian&amp;#95;chroot:+&amp;#40;$debian&amp;#95;chroot&amp;#41;}\u@\h:\w\$ '  
    # primary prompt : contains special characters an sequences for additional info about a session.  
    PS1=&amp;quot;&amp;#91; \u: \w &amp;#93;\\$ &amp;quot;  
    # secondary prompt shows just '&amp;gt;'  
    PS2=&amp;quot;&amp;gt; &amp;quot;  
  fi  
  unset color&amp;#95;prompt force&amp;#95;color&amp;#95;prompt  
&lt;/code&gt;&lt;/pre&gt;&lt;br /&gt;&lt;p&gt;To use it, I created a colorful&lt;i&gt;prompt.sh file with the above content which I put in a  ~/.my&lt;/i&gt;bash&lt;i&gt;config directory, then called it from my ~/.bash&lt;/i&gt;profile file (which is in charge of initializing my terminal) by adding these lines to it:  &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;&amp;#126;/.bash&amp;#95;profile&lt;/code&gt;&lt;/strong&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;  # enable colorful prompt  
  source &amp;#126;/.my&amp;#95;bash&amp;#95;config/colorful&amp;#95;prompt.sh
 &lt;/code&gt;&lt;/pre&gt;  &lt;/p&gt;&lt;p&gt;You can do it all with a simple text editor like TextMate. Don't hesitate to change the colors to your liking, it should be easy from the above code.  Note that this also works on other *nix operating systems, not just OSX.  &lt;/p&gt;&lt;p&gt;Now you have a pretty terminal, which is the first step towards loving to work in the command line.  Next step is to make it more ergonomic.  &lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;using&amp;#95;iterm2&amp;#95;:&amp;#95;panes,&amp;#95;tabs,&amp;#95;profiles&amp;#95;and&amp;#95;window&amp;#95;arrangements&quot;&gt;&lt;/a&gt;Using ITerm2 : panes, tabs, profiles and window arrangements&lt;/h2&gt;  &lt;h3&gt;&lt;a name=&quot;organizing&quot;&gt;&lt;/a&gt;Organizing&lt;/h3&gt;  &lt;p&gt;The first thing I find practical in ITerm2 is the possibility to have several shell sessions open next to each other in the same window.  When using ITerm2, you can have several windows, each window has several tabs, each tab is split into panes.  &lt;/p&gt;&lt;p&gt;I recommend using only one window, making it full-screen, and having many tabs each split into a few panes.  It all looks like this :&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/img/iterm2-screenshot.png&quot; width=&quot;100%&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;small&gt;In this window, there are 6 tabs, and the current tab has 3 panes&lt;/small&gt;  &lt;/p&gt;&lt;p&gt;I'll typically have one or two tabs per project; for example, for a web development project,  I'll have a tab for the frontend and one for the backend. On the backend tab,  I'll have a small pane for my local database server, one for my backend server,  and a large one for git commands and and other command-line stuff.  &lt;/p&gt;&lt;p&gt;To achieve such a layout, use the Shell menu of ITerm2, where you can see options to create new tabs (CMD-T) and split them into panes (CMD-D, CMD-MAJ-D). You can navigate across tabs with CMD-LEFT and CMD-RIGHT.  &lt;/p&gt;&lt;h3&gt;&lt;a name=&quot;having&amp;#95;a&amp;#95;ready-to-use&amp;#95;terminal&amp;#95;with&amp;#95;profiles&amp;#95;and&amp;#95;window&amp;#95;arrangements&quot;&gt;&lt;/a&gt;Having a ready-to-use terminal with profiles and window arrangements&lt;/h3&gt; &lt;p&gt;You don't want to have to re-create this arrangement every time you start ITerm2.  This is why there are profiles and window arrangements.   &lt;/p&gt;&lt;p&gt;A profile is essentially a pre-defined file system location for a shell session to start in.&lt;br /&gt; If you want to always be in the same location in a certain pane, you'll have to create a profile for it.  &lt;/p&gt;&lt;p&gt;To create a profile, do Profiles &gt; Open Profiles &gt; Edit Profile, then +, then you enter the name and file system location for this profile and you're good to go.  &lt;/p&gt;&lt;p&gt;To have a pane with a specific profile, it's a bit tricky.  Place yourself in a pane, click Shell &gt; Split Vertically, then you will prompted for a profile for the newly created pane.  After that, you can close the older pane. I haven't found a more direct way.  &lt;/p&gt;&lt;p&gt;The last thing to do to save your beautiful tabs/panes layout is to save it in a window arrangement.  To do so, go to Window &gt; Save Window Arrangement.  If you want to start ITerm2 with always the same window arrangement (which you probably do),  you can set a default window arrangement in the Preferences.  &lt;/p&gt;&lt;h2&gt;&lt;a name=&quot;wrapping&amp;#95;up&quot;&gt;&lt;/a&gt;Wrapping up&lt;/h2&gt; &lt;p&gt;I hope this will make your relationship to terminal consoles happier.  As Obi-Wan Kenobi said to Luke in the Millennium Falcon, this is your first step into a larger world.  I was actually pleasantly surprised to discover ITerm2 for Mac, I haven't found something as ergonomic for Ubuntu.&lt;/p&gt;
</description>
<pubDate>
Sun, 06 Sep 2015 00:00:00 +0200
</pubDate>
</item>
</channel>
</rss>
